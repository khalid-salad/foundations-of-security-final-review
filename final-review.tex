\documentclass[final]{article}
\usepackage{final-review}
\begin{document}
\include{titlepage}
\section{Advanced crypto}
\subsection{Advanced Cryptographic Primitives}
\begin{itemize}[nosep]
    \item secure multiparty computation
    \item homomorphic encryption
\end{itemize}
\subsection{Commitment Schemes}
\subsubsection*{Commitment Problem}
\begin{itemize}[nosep]
    \item Bob ''calls'' the coin flip (i.e., heads or tails)
    \item Alice flips the coin
    \item Bob wins if her call is correct, Alice wins otherwise
\end{itemize}
Can we prevent Alice from cheating even if the players are not in the same physical location?

\subsubsection*{Commitment Scheme}
\begin{itemize}[nosep]
    \item Two phases
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ chooses a value $V$, $A$ sends a \textbf{commitment} of $V$ to $B$
              \item \underline{reveal}: $A$ reveals the value of $V$
          \end{enumerate}
    \item Example: coin flipping
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ flips a coin, $A$ sends a commitment (i.e., coin is heads or tails) to $B$
          \end{enumerate}
          \begin{itemize}[nosep]
              \item $B$ calls the coin flip (i.e., heads or tails)
          \end{itemize}
          \begin{enumerate}[resume,nosep]
              \item \underline{reveal}: $A$ reveals the value of the coin flip
          \end{enumerate}
    \item Requirements for commitment scheme
          \begin{itemize}[nosep]
              \item $B$ cannot learn the value of $V$ from the commitment
              \item $A$ can reveal only the originally chosen value for a commitment
          \end{itemize}
\end{itemize}
\subsubsection*{Naive Attempt Using Hash Function}
\begin{itemize}[nosep]
    \item $H$: cryptographic hash function
    \item If the set of possible values of $V$ are small (e.g. ``heads'' or ``tails''), $B$ can learn $V$ by simply trying all possible values
\end{itemize}
\subsubsection*{Secure Commitment Using Hash Function}
\begin{itemize}[nosep]
    \item Collision-free hash function $\rightarrow$ $A$ cannot cheat by finding $V_1$ and $V_2$ such that $H(r_1 \mid r_2 \mid V_1) = H(r_1 \mid r_2 \mid V_2)$
          \begin{itemize}
              \item $r_1$ prevents pre-computation of colliding $V_1$ and $V_2$
          \end{itemize}
\end{itemize}
\subsection{Secret Sharing}
\begin{itemize}[nosep]
    \item \underline{Problem}: distribute a secret among $N$ participants such that
          \begin{itemize}[nosep]
              \item any group of at least $T$ participants can reconstruct the secret
              \item no group of fewer than $T$ participants can reconstruct any part of it
          \end{itemize}
    \item Types
          \begin{itemize}[nosep]
              \item \textbf{unconditionally secure}: information-theoretically secure (unbounded attacker)
              \item \textbf{conditionally secure}: typically more efficient
          \end{itemize}
\end{itemize}
\subsubsection*{Special Case: $T = N$}
\begin{itemize}[nosep]
    \item Unconditionally secure scheme:
          \begin{enumerate}[nosep]
              \item let the secret be a binary number $S$
              \item pick $N - 1$ random numbers $R_1$, $R_2$, \dots, $R_{N-1}$ of the same length
              \item give each participant $i$, $i < N$, the number $R_i$
              \item give the last participant the result of $S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}$
          \end{enumerate}
    \item $N$ participants can reconstruct the secret by XORing their numbers:
          \begin{itemize}[nosep]
              \item \begin{align*}&R_1 \xor R_2 \xor \dots \xor R_{N-1} \xor \left(S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}\right) \\&= (R_1 \xor R_1) \xor (R_2 \xor R_2) \xor \dots \xor (R_{N-1} \xor R_{N-1}) \xor S \\&= S\end{align*}
          \end{itemize}
    \item $N - 1$ participants can compute only $S \xor R_i$, where $i$ is the missing participant (or $R_1 \xor R_2 \xor \dots \xor R_{N-1}$ if the last participant is missing)
\end{itemize}
\subsection{Shamir's Secret Sharing}
\begin{itemize}[nosep]
    \item Proposed by Shamir in 1979
    \item Unconditionally secure
    \item Special case $T=2$
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random number $A$
              \item let each participant's share be a random point on the line $Ax + S$
          \end{enumerate}
          \begin{multicols}{2}
              \begin{figure}[H]
                  \begin{tikzpicture}
                      \begin{axis}[xlabel = $x$, ylabel=$y$, ticks=none, ymax=10]
                          \addplot[color=red,thick]{0.8 * x + 1};
                          \addlegendentry{$Ax + S$}
                          \draw[black] (0, 1) circle (2pt) node [right] {$(x_i, y_i)$};
                          \draw[black] (-3, -1.4) circle (2pt) node [right] {};
                          \draw[black] (3, 3.4) circle (2pt) node [right] {};
                      \end{axis}
                  \end{tikzpicture}
              \end{figure}
              \item $T = 2$ participants can reconstruct the secret since any two points define a line
              \item Single participant cannot learn the slope
          \end{multicols}
\end{itemize}
\subsubsection*{General Case}
\begin{itemize}[nosep]
    \item Arbitrary T:
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random numbers $A_1$, $A_2$, $\dots$, $A_{T-1}$
              \item let each participant's share be a random point from the curve
                    \[y = S + A_1 x + A_2 x^2 + \dots + A_{T-1}x^{T-1}\]
          \end{enumerate}
    \item At least $T$ points are necessary to define a polynomial of degree $T - 1$
    \item Example $T = 3$
          \begin{itemize}[nosep]
              \item secret is a parabola (i.e., $A_2 x^2 + A1 x + S$)
              \item there an infinite number of parabolas fitting two points
              \item but three point define one uniquely
          \end{itemize}
\end{itemize}
\subsection{Secure Multiparty Computation}
\begin{itemize}[nosep]
    \item \underline{Problem}: $N$ participants with private data $d_1$, $d_2$, \dots, $d_N$
          \begin{itemize}[nosep]
              \item participants would like to compute the value $F(d_1, d_2, \dots, d_N)$ of a public function $F$ over their private data
              \item no participant $i$ would like to reveal any information about its data $d_i$
          \end{itemize}
    \item Requirements
          \begin{itemize}
              \item \textbf{privacy}: no information is revealed about any private data (other than what is revealed by the public output)
              \item \textbf{correctness}: public function is correctly computed
          \end{itemize}
    \item Adversaries may be semi-honest (passive) or malicious (active)
\end{itemize}
\section{WiFi security}
\subsection{Security Challenge}
\begin{itemize}[nosep]
    \item \underline{Problem}: no inherent physical protection
    \item \textbf{joining} a network does not require physical access
    \item radio transmissions are broadcast $\rightarrow$ anyone in range can \textbf{eavesdrop}
    \item \textbf{injecting} new messages or \textbf{replaying} old messages is possible
    \item \textbf{jamming} attacks against availability
    \item jamming and injecting messages can be combined into \textbf{tampering} attacks
\end{itemize}
\subsection{Simple ''Solutions'' for Access Control}
\subsubsection*{Hidden SSID}
\begin{itemize}[nosep]
    \item Association request must contain the SSID of the network
          \begin{itemize}[nosep]
              \item by default, the AP broadcasts it periodically in the beacon
          \end{itemize}
    \item AP may be configured to \textbf{stop announcing the SSID} $\rightarrow$ SSID may be be used as a ``password''
    \item However,
          \begin{itemize}[nosep]
              \item SSID must be hard to guess
              \item every authorized user must know the SSID
              \item \textbf{SSID can be easily eavesdropped} whenever an authorized station connects to the network $\rightarrow$ does not provide any security
          \end{itemize}
    \item Tools are available for eavesdropping (e.g. Aircrack-ng)
\end{itemize}
\subsubsection*{MAC Address Based Filtering}
\begin{itemize}[nosep]
    \item AP may be configured to \textbf{allow only devices with certain MAC addresses} to connect
          \begin{itemize}[nosep]
              \item MAC addresses of all authorized devices must be registered in advance
          \end{itemize}
    \item However,
          \begin{itemize}[nosep]
              \item \textbf{MAC address is sent in plaintext} in every packet
              \item many WLAN devices allow their MAC addresses to be changed $\rightarrow$ attacker can easily impersonate an authorized user
          \end{itemize}
\end{itemize}
\subsection{802.11 Security Standards}
\subsubsection*{WEP}
\begin{itemize}
    \item security is based on a 40 or 104-bit secret key
          \begin{itemize}[nosep]
              \item WiFi ''password'' shared by all users
          \end{itemize}
    \item \underline{confidentiality}: RC4 stream cipher
          \begin{itemize}[nosep]
              \item key is extended by a 24-bit IV, which is changed for each message $\rightarrow$ used as nonce to prevent key reuse problems
          \end{itemize}
    \item \underline{integrity}: encrypted CRC32 (Cyclic Redundancy Check) checksum
    \item \underline{access control}: challenge-response between AP and station
\end{itemize}
\subsubsection*{WEP Design Flaws}
\begin{itemize}[nosep]
    \item Authentication
          \begin{itemize}[nosep]
              \item \textbf{one-way authentication} (only for station) $\rightarrow$ AP can be impersonated
          \end{itemize}
    \item Integrity protection
          \begin{itemize}[nosep]
              \item based on \textbf{error-detection code} (CRC32) instead of cryptographic hash $\rightarrow$ forging authentication tags is trivial
              \item \textbf{no message replay protection}
          \end{itemize}
    \item Key usage
          \begin{itemize}
              \item \textbf{no session key}: long-term key used for all purposes (authentication, encryption, integrity protection)
              \item \textbf{short nonce} (i.e., 24-bit IV) $\rightarrow$ danger of key reuse for stream cipher
                    \begin{itemize}[nosep]
                        \item busy network with 1000 packets per second reuses in less than 5 hours
                    \end{itemize}
              \item vulnerable to Fluhrer-Mantin-Shamir Attack
                    \begin{itemize}[nosep]
                        \item In practice, WEP keys can be broken in a matter of minutes (or less) $\rightarrow$ WEP is \textbf{not secure}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsection{WiFi Protected Access (WPA)}
\subsubsection*{WPA}
\begin{itemize}[nosep]
    \item Standard: 802.11i TKIP (Temporal Key Integrity Protocol
    \item Design goals: \textbf{fix the flaws of WEP} and be \textbf{compatible with legacy hardware}
    \item Overview
          \begin{itemize}
              \item \underline{key usage}: session key is established during a secure two-way authentication
              \item \underline{confidentiality}: RC4 encryption, but with \textbf{48-bit IV}, which is \textbf{mixed thoroughly} with the session key and source MAC address
                    \begin{itemize}[nosep]
                        \item prevents key reuse and the Fluhrer-Mantin-Shamir attack
                    \end{itemize}
              \item \underline{integrity}: 64-bit message integrity codes computed using Michael, which is \textbf{computationally very efficient} but provides only ~20 bits of effective security
                    \begin{itemize}[nosep]
                        \item after wrong code, station is banned for a minute and needs to re-authenticate
                    \end{itemize}
              \item Deprecated in later revisions of the standard
          \end{itemize}
\end{itemize}
\begin{itemize}
    \item
\end{itemize}
\subsubsection*{WPA-2}
\begin{itemize}[nosep]
    \item Standard: \textbf{IEEE 802.11i}
    \item WPA 2 Devices can be certified by the Wi-Fi Alliance
\end{itemize}
\subsubsection*{Phases}
\begin{enumerate}[nosep]
    \item Discovery
          \begin{itemize}
              \item agree on what authentication method and ciphers to use
          \end{itemize}
    \item Authentication
          \begin{itemize}[nosep]
              \item may use an authentication server
              \item create a master session key
          \end{itemize}
    \item Key management
          \begin{itemize}[nosep]
              \item derive keys for various purposes
          \end{itemize}
    \item Protected data transfer
    \item Connection termination
\end{enumerate}
\subsubsection*{Discovery Phase}
\begin{itemize}[nosep]
    \item \underline{Goal}: station and AP may support different sets of authentication methods and ciphers $\rightarrow$ they need to agree on which ones they will use
    \item \textbf{Authentication and key-management suite}: how to perform mutual authentication and derive fresh keys
          \begin{itemize}[nosep]
              \item IEEE 802.1X, pre-shared key (PSK), or vendor-specific
          \end{itemize}
    \item \textbf{Cipher suite}: what ciphers to use for confidentiality and integrity
          \begin{itemize}
              \item WEP, TKIP, CCMP, or vendor-specific
          \end{itemize}
    \item Protocol
          \begin{enumerate}[nosep]
              \item AP can periodically \textbf{broadcast} its security capabilities using a \textbf{Beacon} (or station can ask for it using a Probe Request message)
              \item Station \textbf{specifies} an authentication and cipher suite in an \textbf{Association Request}
              \item if the AP \textbf{accepts} the specified suites, it sends an \textbf{Association Response}
          \end{enumerate}
\end{itemize}
\subsubsection*{Authentication Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item mutual authentication:
                    \begin{enumerate}[nosep, label=\arabic*)]
                        \item only authorized stations can use the network
                        \item station is assured that it communicates with a legitimate network
                    \end{enumerate}
              \item generate \textbf{pairwise master key} (PMK)
          \end{itemize}
    \item Approaches
          \begin{itemize}[nosep]
              \item Pre-shared key (PSK)
                    \begin{itemize}[nosep]
                        \item password is deployed on each station and the AP manually
                        \item PMK = PSK = generated from the password using a hash function
                        \item ideal for home and small office networks
                    \end{itemize}
              \item IEEE 802.1X
          \end{itemize}
\end{itemize}
\subsubsection*{Key-Management Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item derive \textbf{pairwise transient keys} from the PMK
              \item distribute \textbf{group keys}
          \end{itemize}
    \item Pairwise transient key (PTK)
          \begin{itemize}[nosep]
              \item protecting data between station and AP
              \item generated from PMK and the AP's and station's MAC addresses and nonces
          \end{itemize}
    \item Group temporal key (GTK)
          \begin{itemize}[nosep]
              \item protecting multicast communication
              \item group master key (GMK): generated randomly by the AP
              \item distributed using the PTK
          \end{itemize}
\end{itemize}
\subsubsection*{Protected Data Transfer Phase}
\begin{itemize}[nosep]
    \item Standard defines two schemes: TKIP and CCMP
    \item TKIP: see WPA
    \item CCMP (Counter mode CBC-MAC Protocol)
          \begin{itemize}[nosep]
              \item based on the CCM (Counter with CBC-MAC) authenticated encryption mode
              \item integrity: CBC-MAC based on AES encryption
              \item confidentiality: AES encryption in counter (CTR) mode
              \item same 128-bit key for integrity and confidentiality (from PTK)
              \item 48-bit packet number to prevent replay attacks
          \end{itemize}
\end{itemize}
\subsubsection*{IEEE 802.1X}
\begin{itemize}[nosep]
    \item Standard for port-based network access control
    \item Entities
          \begin{itemize}[nosep]
              \item supplicant = station
              \item authenticator = access point
              \item authentication server
          \end{itemize}
    \item Port-based: supplicant can access only the authentication server until the authentication succeeds
    \item Authentication server does not have to be implemented on the access point $\rightarrow$ little overhead for the access point
\end{itemize}
\subsubsection*{EAP Authentication Methods}
\begin{itemize}[nosep]
    \item Extensible framework, not a specific authentication mechanism
    \item Example methods
          \begin{itemize}[nosep]
              \item EAP-TLS: based on public-key certificates
              \item EAP-GPSK (Generalized Pre-Shared Key): based on secret keys shared by the client and the server, uses symmetric-key cryptography
          \end{itemize}
\end{itemize}
\section{IPSec}
\begin{itemize}[nosep]
    \item Collection of protocols and mechanisms, standardized by the Internet Engineering Task Force (IETF) in a series of publications
    \item Provides
          \begin{itemize}[nosep]
              \item data confidentiality and integrity
              \item source authentication (prevent address spoofing, i.e., sending from fake address)
              \item protection against packet replay
          \end{itemize}
    \item Below the transport layer (TCP or UDP) $\rightarrow$ transparent to applications
    \item End-to-end security between two hosts, a host and a network, or between two networks
    \item Example Applications of IPSec
          \begin{itemize}[nosep]
              \item Secure remote access over the Internet
              \item Secure virtual private network
          \end{itemize}
\end{itemize}
\subsection{Transport Mode and Tunnel Mode}
\begin{itemize}[nosep]
    \item Transport mode
          \begin{itemize}[nosep]
              \item protects the payload of the IP packet
              \item typically host-to-host communication
          \end{itemize}
    \item Tunnel mode
          \begin{itemize}[nosep]
              \item protects the entire IP packet by encapsulating it in the payload of a new IP packet
              \item typically host-to-network or network-to-network communication
          \end{itemize}
\end{itemize}
\begin{table}[H]
    \begin{tabular}{lll}
        \multicolumn{3}{c}{Protocol}                                                                             \\
                 & Authentication Headher (AH)                   & Encapsulating Security Payloads (ESP)         \\\toprule
        Modes    & \multicolumn{2}{c}{both transport and tunnel}                                                 \\
        Provides & integrity, replay protection                  & integrity, confidentiality, replay protection \\
        Protects & payload and IP header                         & payload                                       \\\bottomrule
    \end{tabular}
\end{table}
\subsubsection*{Authentication Header}
\begin{itemize}[nosep]
    \item Services
          \begin{itemize}[nosep]
              \item data and origin integrity
              \item replay-prevention
          \end{itemize}
    \item Message authentication
          \begin{itemize}[nosep]
              \item computed from immutable fields of the IP header, AH header (except ICV), and original payload
              \item algorithms: HMAC-MD5, HMAC-SHA-1, HMAC-SHA-2, \dots
          \end{itemize}
\end{itemize}
\subsubsection*{Encapsulating Security Payload}
\begin{itemize}[nosep]
    \item Services: confidentiality, integrity (optional), replay prevention
    \item Encryption: AES-CBC, 3DES-CBC, \dots
    \item Message authentication: HMAC-SHA-1, AES-GMAC, \dots
    \item Authenticated encryption: AES-GCM
\end{itemize}
\subsubsection*{Combining Modes and Protocols}
\begin{itemize}[nosep]
    \item Tunnel mode advantage: requires support only at the gateways
    \item Transport mode advantage: requires support only at the hosts
    \item AH advantage: authenticates some elements of the original header
    \item ESP advantage: protects both integrity and confidentiality
    \item Combining modes
          \begin{itemize}[nosep]
              \item IPSec tunnel can carry any IP packet $\rightarrow$ IPSec transport or tunnel packets can be sent through an IPSec tunnel
              \item IPSec transport can protect any IP packet $\rightarrow$ IPSec transport or tunnel packets can be protected by outer IPSec transport
              \item \dots
              \item can be nested to any depth
          \end{itemize}
    \item Combination Examples
          \begin{enumerate}[nosep]
              \item AH in transport (for integrity) + ESP in transport (for confidentiality)
              \item IPSec packets over tunnel
          \end{enumerate}
\end{itemize}
\section{SSL / TLS}
\subsubsection*{Secure Socket Layer}
\begin{itemize}[nosep]
    \item End-to-end security between two applications
    \item Endpoint applications can implement it without the help of the operating systems or any intermediate devices
    \item Developed by Netscape for securing HTTP $\rightarrow$ HTTPS = HTTP over SSL
    \item very widely used, not just for HTTP (e.g. FTP, POP3, IMAP)
\end{itemize}
\subsubsection*{Overview}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,rectangle,fill=gray!40,node distance=0cm,minimum height=1.5cm, minimum width=2cm}]
        \node (handshake) {SSL\\Handshake\\Protocol};
        \node[right=of handshake] (cipher) {SSL Change\\Cipher Spec\\Protocol};
        \node[right=of cipher] (alert) {SSL Alert\\Protocol};
        \node[right=of alert] (http) {HTTP};
        \path (handshake.south west) rectangle ([yshift=-1.5cm]http.south east) node[pos=0.5,minimum width=8.15cm] (record) {SSL Record Protocol};
        \path (record.south west) rectangle ([yshift=-1.5cm]record.south east) node[pos=0.5,minimum width=8.15cm] (tcp) {TCP};
        \path (tcp.south west) rectangle ([yshift=-1.5cm]tcp.south east) node[pos=0.5,minimum width=8.15cm] (ip) {IP};

        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=handshake, node distance=4cm] (negotiation) {algorithm negotiation,\\key exchange,\\authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=record, node distance=7cm] (encryption) {encryption and\\message authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,above of=cipher, node distance=2cm] (switch) {switching algorithms\\and keys};
        \node[minimum size=0cm,inner sep=-0.05cm,fill=none,draw=none,above of=http,node distance=2cm] (sending) {sending SSL related\\alerts, which may\\terminate the connection};

        \draw[->] (negotiation.north east) to[bend left] ([xshift=0.5cm,yshift=0.1cm]handshake.north west);
        \draw[->] (encryption.north east) to[bend left] (record.west);
        \draw[->] (switch.south) to ([yshift=0.1cm]cipher.north);
        \draw[->] (sending.south west) to[bend right] ([xshift=0.5cm,yshift=0.1cm]alert.north west);
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSL Record Protocol}
\begin{itemize}[nosep]
    \item Security 528
          \begin{itemize}[nosep]
              \item confidentiality: symmetric-key encryption (AES GCM, Salsa20, \dots)
              \item integrity: message authentication codes based on symmetric-key cryptography (HMAC-SHA256, \dots)
          \end{itemize}
    \item Additional Services
          \begin{itemize}[nosep]
              \item fragmentation: fragment application data into records of at most 16 KiB
              \item lossless compression: optional (default is no compression)
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Handshake Protocol}
\begin{itemize}[nosep]
    \item Phase 1: establish security capabilities
          \begin{itemize}[nosep]
              \item client\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by the client
                        \item nonce (timestamp + random value)
                        \item cipher suite: list of key-exchange methods, as well as encryption and MAC algorithms
                        \item compression method: list of supported compression algorithms
                    \end{itemize}
              \item server\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by both the
                              client and the server
                        \item nonce
                        \item chosen cipher suite and compression method
                    \end{itemize}
          \end{itemize}
    \item Phase 2: server authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate (may be a chain)
              \item server\_key\_exchange (optional):
                    \begin{itemize}[nosep]
                        \item parameters for Anonymous or Ephemeral Diffie-Hellman exchange
                        \item public-key for RSA exchange if the certificate contains only a signing key
                        \item signed by the server (together with the nonces)
                    \end{itemize}
              \item certificate\_request (optional): ask client for an X.509 certificate
              \item server\_hello\_done: server is finished
          \end{itemize}
    \item Phase 3: client authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate if the server asked for a client certificate
              \item client\_key\_exchange:
                    \begin{itemize}[nosep]
                        \item pre-master secret encrypted using public RSA key of the server
                        \item parameters for D-H exchange
                    \end{itemize}
              \item certificate\_verify (optional): digital signature of all previous handshake messages
          \end{itemize}
\end{itemize}
\subsubsection*{Key Exchange Methods}
\begin{itemize}[nosep]
    \item Goal: exchange or agree on a pre-master secret (PMS)
    \item RSA
          \begin{itemize}[nosep]
              \item client generates pre-master secret (PMS)
              \item sends PMS to the server encrypted using RSA public-key encryption
          \end{itemize}
    \item Diffie-Hellman protocol
          \begin{itemize}[nosep]
              \item anonymous D-H: basic D-H with no authentication
              \item fixed D-H: D-H parameters of the server ($X_A$ and $Y_A$) are fixed and $Y_A$ is contained in a digital certificate
              \item ephemeral D-H: D-H with authentication
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Change Cipher Spec Protocol}
\begin{itemize}[nosep]
    \item Same for client and server
          \begin{itemize}[nosep]
              \item change\_cipher\_spec: signals that the communication party is switching to the negotiated cryptographic algorithms and keys
              \item finished: hash value computed from the master secret and all handshake messages using HMAC with SHA hash function
          \end{itemize}
\end{itemize}
\subsubsection*{Session Resume}
\begin{itemize}
    \item Authentication and key exchange are complex $\rightarrow$ result needs to be reusable
    \item Session
          \begin{itemize}[nosep]
              \item association between a client and a server
              \item cipher suite, compression method, and master secret
          \end{itemize}
    \item Connection
          \begin{itemize}[nosep]
              \item within a session
              \item keys and IVs for encryption and message authentication
          \end{itemize}
    \item Session ID: identifies a session
          \begin{itemize}[nosep]
              \item sent in ClientHello $\rightarrow$ may specify an existing session to be resumed
              \item sent in ServerHello $\rightarrow$ server can accept resume by sending the same ID
          \end{itemize}
    \item Session resume skips all messages in the Handshake after the ClientHello and ServerHello messages
          \begin{itemize}[nosep]
              \item new keys and IVs are generated from the nonces in the Hello messages
          \end{itemize}
\end{itemize}

\subsubsection*{Transport Layer Security}
\begin{itemize}[nosep]
    \item only minor differences compared to SSL 3.0:
          \begin{itemize}[nosep]
              \item pseudorandom function for generating keys and MAC is based on HMAC
              \item variable length padding (may prevent traffic analysis)
              \item other minor changes
          \end{itemize}
\end{itemize}
\subsubsection*{HTTPS}
\begin{itemize}[nosep]
    \item HTTP over SSL/TLS
    \item Between the web browser and server:
          \begin{itemize}[nosep]
              \item HTTP client = SSL client
              \item HTTP server = SSL server
          \end{itemize}
    \item Conventions
          \begin{itemize}[nosep]
              \item URL: \texttt{http\textbf{s}://} instead of \texttt{http://}
              \item default TCP port is 443 instead of 80
          \end{itemize}
    \item HTTP request may be sent after SSL Finished messages
    \item Protected information
          \begin{itemize}[nosep]
              \item URL, contents of the document, browser forms, cookies, headers
              \item page served over HTTPS may include elements retrieved using HTTP
          \end{itemize}
\end{itemize}
\section{DNSSEC}
\subsubsection*{Domain Name System (DNS)}
\begin{itemize}[nosep]
    \item Millions of domain names $\rightarrow$ distributed database
          \begin{itemize}[nosep]
              \item dynamic data $\leftarrow$ IP address for a host may change
              \item decentralized authority $\leftarrow$ each name has an owner
          \end{itemize}
    \item Hierarchical name space
          \begin{itemize}[nosep]
              \item domain: node in the DNS tree
              \item for each domain, there is an authoritative server
          \end{itemize}
    \item Authoritative server
          \begin{itemize}[nosep]
              \item responds to queries about the domains for which it is responsible
              \item may refer to other authoritative servers for a subdomain
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Queries and Responses}
\begin{itemize}[nosep]
    \item Transport protocol
          \begin{itemize}[nosep]
              \item UDP port 53
              \item TCP for long responses (and some tasks between nameservers)
          \end{itemize}
    \item Messages: query and reply
          \begin{itemize}[nosep]
              \item 16-bit identification field: match queries with replies
          \end{itemize}
    \item Caching
          \begin{itemize}[nosep]
              \item received responses are cached by servers
              \item each record has a Time-to-Live field, after expiry it must be queried again
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Weaknesses}
\begin{itemize}[nosep]
    \item DNS responses are not authenticated
          \begin{itemize}[nosep]
              \item responses can be sent over UDP transport protocol $\rightarrow$ anyone can respond from a spoofed (i.e., fake) IP address to a query
          \end{itemize}
    \item DNS is a key infrastructure
          \begin{itemize}[nosep]
              \item resolvers trust responses, users trust resolvers
              \item by tampering with responses, an attacker may direct users to malicious websites or direct e-mail to malicious servers
          \end{itemize}
    \item DNS cache poisoning
          \begin{itemize}[nosep]
              \item attacker sends malicious response to a DNS server, which caches it $\rightarrow$ malicious response is served to all clients using the server
              \item attacker does not have to be man-in-the-middle
          \end{itemize}
    \item Race to Respond First
          \begin{itemize}[nosep]
              \item If the attacker responds before the authoritative server, the DNS cache is poisoned with the malicious IP address
                    \begin{itemize}[nosep]
                        \item fake response is a single UDP packet from the spoofed (i.e., forged) IP address of the authoritative server
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Domain Name System Security Extensions (DNSSEC)}
\begin{itemize}[nosep]
    \item Set of extensions defined by the IETF to the DNS protocol
    \item Guarantees origin authenticity and data integrity of DNS replies
    \item Backwards compatible: responses can be interpreted by DNS servers and clients that do not support DNSSEC
          \begin{itemize}[nosep]
              \item of course, no guarantees are provided for these servers and clients
          \end{itemize}
    \item Does not provide confidentiality
          \begin{itemize}[nosep]
              \item responses are only authenticated but not encrypted
          \end{itemize}
    \item Based on public-key cryptography
          \begin{itemize}[nosep]
              \item every response is digitally signed
          \end{itemize}
\end{itemize}
\subsubsection*{DNSSEC Public Keys and Signatures}
\begin{itemize}[nosep]
    \item Signature algorithms: RSA-SHA1, RSA-SHA256, ECDSA-SHA256, \dots
    \item Trust anchor
          \begin{itemize}[nosep]
              \item known public key for an authoritative nameserver
              \item typically included in the operating systems
          \end{itemize}
    \item Authentication chain
          \begin{figure}[H]
              \begin{tikzpicture}
                  \node (anchor) {trust anchor};
                  \node[below right =of anchor] (root) {root};
                  \node[right =of root] (edu) {edu};
                  \node[right =of edu] (uh) {uh.edu};
                  \draw[->] (anchor) to[bend right] (root);
                  \draw[->] (root) -- (edu) node[above,pos=0.5] {signs};
                  \draw[->] (edu) -- (uh) node[above,pos=0.5] {signs};
              \end{tikzpicture}
          \end{figure}
    \item Responses may include
          \begin{itemize}[nosep]
              \item RRSIG: digital signature for the contents of the response
              \item DNSKEY: public key for a zone $\leftarrow$ if the response delegates
          \end{itemize}
\end{itemize}
\subsubsection*{DNS over HTTPS and TLS}
\begin{itemize}[nosep]
    \item DNS over HTTPS (DoH)
          \begin{itemize}[nosep]
              \item DNS queries and responses are encoded into HTTPS requests and responses
                    \begin{itemize}[nosep]
                        \item provides integrity and confidentiality
                        \item server may use HTTP/2 Push to send records in advance
                    \end{itemize}
              \item controversies and criticism: can impede traffic analysis for cybersecurity, may provide false sense of privacy, can impede traffic filtering by ISPs, \dots
          \end{itemize}
    \item DNS over TLS (DoT)
          \begin{itemize}[nosep]
              \item provides integrity and confidentiality
          \end{itemize}
\end{itemize}
\section{SSH}
\subsubsection*{Secure Shell (SSH) Protocol Stack}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,fill=gray!40,minimum width=6cm,minimum height=2.2cm,node distance=0cm}]
        \node (auth) {\textbf{SSH User}\\\textbf{Authentication Protocol}\\Authenticates the client-side\\user to the server.};
        \node[right =of auth] (conn) {\textbf{SSH}\\\textbf{Connection Protocol}\\Multiplexes the encrypted\\tunnel into several logical\\channels.};
        \path (auth.south west) rectangle ([yshift=-2.2cm]conn.south east) node[pos=0.5,minimum width=12.02cm] (transport) {\textbf{SSH Transport Layer Protocol}\\Provides server authentication, confidentiality, and integrity.\\It may optionally also provide compression.};
        \path (transport.south west) rectangle ([yshift=-2.2cm]transport.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (tcp) {\textbf{TCP}\\Transmission control protocol provides reliable, connection-\\oriented end-to-end delivery.};
        \path (tcp.south west) rectangle ([yshift=-2.2cm]tcp.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (ip) {\textbf{IP}\\Internet protocol provides datagram delivery across\\multiple networks.};
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSH Transport Layer}
\begin{itemize}
    \item Packet Exchange
    \item Identification string exchange
          \begin{itemize}[nosep]
              \item both the client and the server send: \texttt{SSH-protocolVersion-softwareVersion}
          \end{itemize}
    \item Algorithm negotiation (KEXINIT)
          \begin{itemize}[nosep]
              \item both the client and the server send the list of key exchange, encryption, MAC, and compression algorithms that they support
              \item chosen one: first on the client's list that is also on the server's list
          \end{itemize}
    \item End of key exchange (NEWKEYS)
          \begin{itemize}[nosep]
              \item start using the algorithms and keys
          \end{itemize}
\end{itemize}
\subsubsection*{Server authentication}
\begin{itemize}[nosep]
    \item servers signs a hash of all the earlier messages and the new symmetric key
    \item servers sends the signature and its public key to the client
    \item Client needs to verify the public-key sent by the server (i.e., verify that the public key belongs to the server host)
    \item Trust models
          \begin{itemize}[nosep]
              \item Certificate authority
                    \begin{itemize}[nosep]
                        \item client accepts public keys that are certified by a trusted CA
                    \end{itemize}
              \item Local database
                    \begin{itemize}[nosep]
                        \item client has a list of known pairs of hosts and public-keys
                        \item typically, each user has a list stored in its home directory
                              \begin{itemize}[nosep]
                                  \item default location: \texttt{\~{}/.ssh/known\_hosts}
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
    \item Known Hosts
          \begin{itemize}[nosep]
              \item First connection: verify and store host and public key
              \item Subsequence connections: compare to stored key
          \end{itemize}
\end{itemize}
\subsubsection*{SSH User Authentication Methods}
\begin{itemize}[nosep]
    \item Passwords
          \begin{itemize}[nosep]
              \item client sends a username and a password
          \end{itemize}
    \item Public key
          \begin{itemize}[nosep]
              \item client sends a public key and a signature based on the corresponding private key
              \item server checks if the public key is acceptable and verifies the signature
              \item typically, for every user account on the server host, there is a list of acceptable public keys stored at \texttt{\~{}/.ssh/authorized\_keys}
          \end{itemize}
    \item Host based
          \begin{itemize}[nosep]
              \item assumes that the server trusts the client host $\rightarrow$ since the client host has already authenticated the user, the server only needs to verify the identity of the client host
              \item client sends a signature based on the private key of the client host
          \end{itemize}
\end{itemize}
\section{E-mail security}
\subsubsection*{Weaknesses}
\begin{itemize}[nosep]
    \item Simple Mail Transfer Protocol
          \begin{itemize}[nosep]
              \item Outgoing emails can be tampered (integrity), eavesdropped (confidentiality), or forged (authenticity/integrity)
          \end{itemize}
\end{itemize}
\subsubsection*{E-Mail Threats}
\begin{itemize}[nosep]
    \item Spam: unsolicited messages sent in bulk
    \item E-mail scam: advance-fee scam (a.k.a. ``Nigerian Prince'' scam), job scam, \dots
    \item Phishing: collecting sensitive information (e.g. passwords, credit card numbers) or delivering malware by impersonating a trusted entity
    \item Spear-phishing: phishing directed at specific targets (e.g. users)
\end{itemize}
\subsubsection*{Pretty Good Privacy (PGP)}
\begin{itemize}[nosep]
    \item General-purpose application for secure communication between users
          \begin{itemize}[nosep]
              \item confidentiality and integrity protection for files and e-mail
              \item built on widely used asymmetric and symmetric-key cryptographic algorithms
              \item communicating users know each other's public keys $\rightarrow$ trust
          \end{itemize}
    \item IETF standard: OpenPGP
    \item Software
          \begin{itemize}[nosep]
              \item PGP went commercial in 1996
              \item GnuPG is a free and open-source implementation of OpenPGP
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Key Management}
\begin{itemize}[nosep]
    \item Each user may have multiple public-private key pairs $\rightarrow$ key identifiers are used to specify which key is used
    \item Key storage
          \begin{itemize}[nosep]
              \item private-key ring: user's own public-private key pairs
                    \begin{itemize}[nosep]
                        \item each entry has user identifier, key identifier, public key, encrypted private key
                        \item private key is encrypted using a passphrase
                    \end{itemize}
              \item public-key ring: public keys of other users
                    \begin{itemize}[nosep]
                        \item each entry has user identifier, key identifier, public key, trust levels, and signatures from other users
                        \item public-keys can be verified directly (e.g. delivery on secure channel) or using the ''web of trust''
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Web of Trust}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={draw,circle,minimum size=1cm,label distance=0mm}]
        \node[fill=gray!40,label=above right:\textbf{You}] (you) {};
        \node[below left =of you,label=above:\textbf{A}] (a) {};
    \end{tikzpicture}
\end{figure}
\subsubsection*{PGP Authentication}
\begin{itemize}[nosep]
    \item Digital signature using the sender's private key
          \begin{itemize}[nosep]
              \item hash using MD5, SHA-1 or SHA-2, and then sign using RSA or DSA
          \end{itemize}
    \item Message may be compressed after signature
          \begin{itemize}[nosep]
              \item ZIP, Bzip2, \dots
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Encryption}
\begin{itemize}
    \item Message may be compressed before encryption
          \begin{itemize}[nosep]
              \item ZIP, Bzip2, \dots
          \end{itemize}
    \item Generate a new 128-bit random symmetric key for each message
          \begin{itemize}[nosep]
              \item encrypt the message with the symmetric key using a block cipher in CFB mode (3DES, Blowfish, AES, \dots)
              \item encrypt the symmetric key with the recipient's public key using RSA or ElGamal
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME}
\begin{itemize}[nosep]
    \item MIME (Multipurpose Internet Mail Extension)
          \begin{itemize}[nosep]
              \item fixes the limitations posed by SMTP
              \item New headers fields
                    \begin{itemize}[nosep]
                        \item Content-Type: type of message content
                              \begin{itemize}[nosep]
                                  \item multipart type: body contains multiple parts, each having a header (e.g. images in HTML message, attachments)
                                  \item simple types (e.g. text/plain, image/jpeg, text/html)
                              \end{itemize}
                        \item Content-Transfer-Encoding: how binary data is represented in 7-bit ASCII (e.g. Base64, quoted-printable)
                    \end{itemize}
          \end{itemize}
    \item Secure / Multipurpose Internet Mail Extension (S/MIME)
          \begin{itemize}[nosep]
              \item security enhancement to the MIME e-mail format standard
              \item similar to PGP (Pretty Good Privacy)
                    \begin{itemize}[nosep]
                        \item both S/MIME and PGP enable encrypting and signing messages
                        \item both have IETF standards
                        \item both support state-of-the-art algorithms (AES, RSA, SHA-2, ...)
                        \item S/MIME is likely to emerge as the industry standard for commercial and organizational use (e.g. Microsoft Outlook and Gmail support S/MIME)
                        \item PGP is likely to remain the choice for personal e-mail security
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME Functionality}
\begin{itemize}[nosep]
    \item Functions
          \begin{itemize}[nosep]
              \item Signed data: message is digitally signed, and both the signature and the message are encoded (using Base64 representation)
              \item Clear-signed data: similar to signed data, but only the signature is encoded
              \item Enveloped data: encrypted message content and encrypted content-encryption key (i.e., session key) for one or more recipients (encoded using Base64)
              \item Signed and enveloped data: signing and encrypting may be nested
          \end{itemize}
    \item MIME content types
          \begin{itemize}[nosep]
              \item application/pkcs7-mime: signed or enveloped data
              \item multipart/signed: for clear-signed data, which contains a message and a signature (signature part is application/pkcs7-signature)
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME Public Keys}
\begin{itemize}[nosep]
    \item Public-key certificates
          \begin{itemize}[nosep]
              \item based on X.509 digital certificate format
              \item similar to PGP, digital certificates are distributed manually
              \item however, certificates may be signed by a CA
          \end{itemize}
    \item Public keys are used for
          \begin{itemize}[nosep]
              \item verifying signatures
              \item encrypting session keys
                    \begin{itemize}[nosep]
                        \item for enveloped data, the sender generates a random session key
                        \item session key is encrypted with each recipient's public key, and the message contents are encrypted (using symmetric-key crypto) with the session key
                        \item upon receiving the message, a recipient can decrypt the session key, and then decrypt the message contents using the session key
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{DKIM}
\begin{itemize}
    \item E-Mail Spoofing Problem
    \item Attackers may use e-mail with forged sender addresses for spam/phishing
    \item Limitations of PGP and S/MIME
          \begin{itemize}[nosep]
              \item depend on the sending and receiving users, who must install or configure software, share public keys, etc.
              \item do not sign the message header, only the message contents
          \end{itemize}
    \item DomainKeys Identified Mail (DKIM)
          \begin{itemize}[nosep]
              \item specification for signing e-mail messages
              \item implemented on the servers, therefore transparent to the users
          \end{itemize}
\end{itemize}
\subsubsection*{DKIM Signature and Verification}
\begin{itemize}[nosep]
    \item Signature: Dkim-Signature header field
          \begin{itemize}[nosep]
              \item v: version
              \item a: algorithm used for signature (RSA-SHA1, RSA-SHA256)
              \item d: domain name
              \item s: selector (if there are multiple public keys)
              \item h: list of signed header fields
              \item bh: hash of the body part of the message
              \item b: signature in Base64
          \end{itemize}
    \item Verification
          \begin{itemize}[nosep]
              \item receiving SMTP server queries record s.\_domainkey.d using DNS
              \item nameserver returns the public key corresponding to the signing private key
          \end{itemize}
\end{itemize}
\subsubsection*{E-Mail Authentication Solutions}
\begin{itemize}[nosep]
    \item DomainKeys Identified Mail (DKIM)
    \item Sender Policy Framework (SPF)
          \begin{itemize}[nosep]
              \item another system for preventing e-mail spoofing
              \item DNS record lists all authorized sending hosts (i.e., e-mail servers) for a domain $\rightarrow$ receiving server can verify
              \item may be combined with DKIM
          \end{itemize}
    \item Domain-based Message Authentication, Reporting and Conformance (DMARC)
          \begin{itemize}[nosep]
              \item built on top of DKIM and SPF, published using DNS record
              \item enables domain owners to publish a policy (combination of DKIM and SPF) for verifying the legitimacy of e-mails from the domain
          \end{itemize}
\end{itemize}
\section{Authentication and access control}
\subsubsection*{Authentication}
\begin{itemize}[nosep]
    \item Authentication: reliably verifying the identity of someone or something
          \begin{itemize}[nosep]
              \item computer authenticates another computer
              \item computer authenticates a user
          \end{itemize}
    \item Types of authentication
          \begin{itemize}[nosep]
              \item one-way authentication or mutual authentication
              \item one-time or establishing a session (e.g. combined with key exchange)
          \end{itemize}
    \item Typical methods of computer authentication
          \begin{itemize}[nosep]
              \item cryptography-based
              \item address-based
          \end{itemize}
\end{itemize}
\subsubsection*{User Authentication}
\begin{itemize}[nosep]
    \item Types of user authentication factors
          \begin{itemize}[nosep]
              \item knowledge: some secret known only by the user (e.g. password)
              \item ownership: some physical object possessed by the user (e.g. bank card)
              \item inherence: some physical characteristic of the user (e.g. fingerprint)
          \end{itemize}
    \item Password-based user authentication
          \begin{itemize}[nosep]
              \item typical form of knowledge-based authentication
              \item verifier stores the password in a database or file
              \item often combined with cryptography-based approaches to protect the password from eavesdropping
              \item password must be easy to remember but hard to guess
          \end{itemize}
\end{itemize}
\subsubsection*{Password-Based Authentication}
\begin{itemize}
    \item Problem: easy-to-remember passwords are weak
          \begin{itemize}[nosep]
              \item Miller's law: number of objects an average human can hold in working memory is $7 \pm 2$
              \item length of passwords that users can easily remember (i.e., not write down somewhere) is very limited
          \end{itemize}
    \item Brute-force attack: password guessing
          \begin{itemize}
              \item online: attacker must rely on the verifier to test the correctness of a password $\rightarrow$ verifier can limit the number of attempts (e.g. number of unsuccessful login)
              \item offline: attacker can test the correctness of a password on its own
          \end{itemize}
\end{itemize}
\subsubsection*{Password Storage}
\begin{itemize}[nosep]
    \item Cleartext passwords are insecure
          \begin{itemize}[nosep]
              \item system administrators (and other local users) may easily read passwords
              \item attackers who have compromised a system may be able to read passwords
          \end{itemize}
    \item Users tend to reuse passwords $\rightarrow$ breach may affect other systems as well
    \item Store the cryptographic hash of the password
          \begin{itemize}[nosep]
              \item during authentication, the user enters the plaintext password, and the verifier computes its hash and compares it with the stored hash
              \item attacker can perform offline guessing to recover the plaintext password
          \end{itemize}
    \item Brute-forcing multiple hashed passwords
          \begin{itemize}[nosep]
              \item first, precompute a table of [password, hash] values for possible passwords
              \item second, for each hashed password, look up the precomputed hash value
          \end{itemize}
\end{itemize}
\subsubsection*{Salting}
\begin{itemize}[nosep]
    \item Before hashing a password mix it with a salt value
          \begin{itemize}[nosep]
              \item both when the password is set and during verification
              \item verifier stores: username, salt, H(password + salt)
          \end{itemize}
    \item Salt value
          \begin{itemize}
              \item randomly generated for each user account
              \item may be stored in plaintext by the verifier
          \end{itemize}
    \item Salt values do not have to be memorized $\rightarrow$ strong randomness
          \begin{itemize}
              \item prevents precomputing hashes since the attacker cannot consider all possible salt values (different salt values require different precomputation)
              \item also hides identical passwords, which would result in identical hashes
          \end{itemize}
    \item However, it does not make guessing a single password harder (assuming that the attacker knows the salt)
\end{itemize}
\subsubsection*{Multi-Factor Authentication}
\begin{itemize}[nosep]
    \item User is authenticated only after passing multiple independent authentication mechanisms
          \begin{itemize}[nosep]
              \item typically, each mechanism is built on a different type of factor (e.g. knowledge + possession), so it is independent of the other mechanisms
              \item attacker must circumvent all authentication mechanisms to succeed
          \end{itemize}
    \item Possession factors
          \begin{itemize}[nosep]
              \item disconnected token: not connected to the client computer, typically the user manually enters authentication data displayed by the token
              \item connected token: physically connected to the client computer (e.g. USB token)
          \end{itemize}
    \item Inherence factors
          \begin{itemize}
              \item includes fingerprint, face, voice, or iris recognition
          \end{itemize}
\end{itemize}
\subsubsection*{Access Control}
\begin{itemize}[nosep]
    \item Access control (i.e., authorization): approving or rejecting access requests
    \item Abstractions
          \begin{itemize}[nosep]
              \item subjects: entities that can perform actions on the system
              \item objects: resources to which access must be controlled
          \end{itemize}
    \item Control access to objects based on a policy
\end{itemize}
\subsubsection*{Discretionary Access Control (DAC)}
\begin{itemize}[nosep]
    \item Allows access rights to be propagated at the subjects' discretion
    \item Often implemented using the notion of owner
          \begin{itemize}[nosep]
              \item every object has an owner subject, who can set the permissions for that object
          \end{itemize}
    \item Used by popular operating systems (e.g. Unix and Windows)
    \item Problem: non-malicious users are not necessarily trustworthy
          \begin{itemize}[nosep]
              \item phishing: subjects may be tricked into propagating their access rights to malicious entities
              \item malware: malicious code running with a subject's credentials can disclose or modify sensitive information
              \item large organizations working with sensitive data may need centralized control
          \end{itemize}
\end{itemize}
\subsubsection*{Mandatory Access Control (MAC)}
\begin{itemize}[nosep]
    \item Restricts the access of subjects to objects based on a system-wide set of rules
          \begin{itemize}[nosep]
              \item system-wide rules are set by a central authority (e.g. system administrator)
              \item policy is mandatory $\rightarrow$ users do not have full control over access to the resources that they create
          \end{itemize}
    \item Traditionally used for implementing multilevel security
          \begin{itemize}[nosep]
              \item objects have security classifications (e.g. ''Top Secret'', ''Secret'')
              \item subjects have security clearances
          \end{itemize}
    \item Available in some form on many modern operating systems
          \begin{itemize}[nosep]
              \item SELinux and AppArmor for Linux, and Mandatory Integrity Control for Windows
          \end{itemize}
    \item May be combined with DAC: grant access only if both DAC and MAC permit the access
\end{itemize}
\subsubsection*{Access Control Models}
\begin{itemize}[nosep]
    \item Access control list (ACL): list permissions for each object
          \begin{itemize}[nosep]
              \item for each object, list pairs of [subject, access right]
          \end{itemize}
    \item Role-based access control (RBAC): row oriented
          \begin{itemize}[nosep]
              \item create a set of roles (e.g. based on real-world job functions), and assign a role (or roles) to each subject
              \item for each role, list pairs of [object, access right]
          \end{itemize}
\end{itemize}
\subsubsection*{Unix Access Control}
\begin{itemize}[nosep]
    \item user: has a unique UID (special UID = 0 for root user)
    \item group (collection of multiple users): has a unique GID
    \item Access control abstraction
          \begin{itemize}[nosep]
              \item subject = process
                    \begin{itemize}[nosep]
                        \item has an effective UID and GID (as well as real and saved UIDs and GIDs)
                    \end{itemize}
              \item object = file
                    \begin{itemize}[nosep]
                        \item has an owner (UID) and a group (GID), typically inherited from the process that created the file
                        \item almost everything is a file on a Unix system (regular files, directories, devices, Unix domain sockets, \dots)
                    \end{itemize}
              \item Each file has 12 permission bits
                    \begin{itemize}[nosep]
                        \item read, write, and execute permission for owner, group, and others
                        \item set user ID (setuid), set group ID (setgid), sticky bits
                    \end{itemize}
              \item When a process wants to read/write/execute a file,
                    \begin{enumerate}[nosep]
                        \item if effective UID = file owner $\rightarrow$ use read/write/execute permission for owner
                        \item else if effective GID = file group $\rightarrow$ use read/write/execute permission for group
                        \item else $\rightarrow$ use read/write/execute permission for others
                    \end{enumerate}
              \item For directories,
                    \begin{itemize}[nosep]
                        \item read means listing the contents of the directory
                        \item write means creating, renaming, and deleting files in the directory
                        \item execute means accessing the files (and directories) within the directory (must also have execute permission on all the parent directories)
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Sticky, Set UID, and Set GID Bits}
\begin{itemize}[nosep]
    \item Sticky bit
          \begin{itemize}[nosep]
              \item when set on a directory, files within that directory can be renamed or deleted only by their owners, the directory owner, or a superuser
              \item for example, sticky bit is typically used on the /tmp directory
          \end{itemize}
    \item Set UID bit
          \begin{itemize}[nosep]
              \item when set on an executable file, the effective UID of a process executing the file is set to the file owner UID
              \item for example, set UID bit is typically used on the passwd command
          \end{itemize}
    \item Set GID bit
          \begin{itemize}[nosep]
              \item when set on an executable file, the effective GID of a process executing the file is set to the file group GID
              \item when set on a directory, new files created within will inherit the GID of the directory
          \end{itemize}
\end{itemize}
\section{Software vulnerabilities and countermeasures}
\subsubsection*{Buffer Overflow}
\begin{itemize}[nosep]
    \item Buffer overflow / buffer overrun: anomalous condition where a process tries to store data beyond the boundaries of a fixed-length buffer
          \begin{itemize}[nosep]
              \item extra data overwrites adjacent memory, which may lead to denial-of-service or arbitrary code execution
          \end{itemize}
    \item Vulnerable programming languages
          \begin{itemize}[nosep]
              \item C, C++ and other ''lower-level'' languages without bounds checking
              \item ``higher-level'' languages, such as Java and C\#, are generally not vulnerable
          \end{itemize}
    \item Attacker can supply malicious (i.e., long) input
          \begin{itemize}[nosep]
              \item remotely through a network connection (e.g. specially crafted HTTP request)
              \item locally (e.g. by sending a specially crafted file to the target user)
          \end{itemize}
\end{itemize}
\subsubsection*{Typical Buffer Overflow Exploits}
\begin{itemize}[nosep]
    \item Attacker's goal: execute arbitrary code (i.e., code chosen by the attacker)
    \item execute arbitrary code (i.e., code chosen by the attacker)
    \item Stack-based exploitation (''stack smashing'')
          \begin{itemize}[nosep]
              \item overflow a local buffer
              \item overwrite local variables, function return addresses, exception handlers, etc.
          \end{itemize}
    \item Heap-based exploitation
          \begin{itemize}
              \item overflow a dynamically allocated buffer
              \item overwrite other data, function pointers, etc.
          \end{itemize}
    \item Shellcode: small piece of code, which allows the attacker to control the compromised machine
\end{itemize}
\subsubsection*{Buffer-Overflow Exploit Countermeasures}
\begin{itemize}
    \item Compile-time -- hardening new software
          \begin{itemize}[nosep]
              \item programming languages
              \item safe functions and libraries
              \item compiler extensions
          \end{itemize}
    \item Run-time -- protecting existing software
          \begin{itemize}[nosep]
              \item executable space protection
                    \begin{itemize}[nosep]
                        \item Lot of exploits build on injecting and executing malicious code
                        \item By separating the memory space of a process into executable and modifiable parts, code injection can be prevented
                        \item Problem: modern computer architectures do not separate code from data
                        \item Limitation: cannot fully protect programs that create and execute code at runtime (e.g. just-in-time compilers)
                        \item Circumventing Executable Space Protection
                              \begin{itemize}[nosep]
                                  \item Attacker can re-use existing code from the memory space of the process for malicious purposes
                                  \item Return-to-libc attack
                                  \item for most processes, the standard C library is loaded into memory
                                  \item attacker can change the return address of a function to point to the beginning of a function in the C library
                                  \item common target: system function -- takes as argument a string, and executes it as a system command with the privileges of the process
                                  \item attacker has control over the stack $\rightarrow$ attacker can set up parameters for the C library function
                              \end{itemize}
                    \end{itemize}
              \item address space layout randomization
                    \begin{itemize}[nosep]
                        \item In order to reliably jump to an exploited code, the attacker needs to know its address
                        \item Address Space Layout Randomization (ASLR)
                              \begin{itemize}[nosep]
                                  \item randomly arrange the positions of the executable, the stack, and the heap in the process's address space
                                  \item may prevent return-to-libc attacks
                                  \item most operating systems (e.g. Windows, Linux) implement some randomization
                              \end{itemize}
                        \item Counter-countermeasures
                              \begin{itemize}[nosep]
                                  \item information leakage (e.g. printf vulnerability)
                                  \item random guessing (Heap spraying)
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Integer Overflow}
\begin{itemize}[nosep]
    \item Integer overflow occurs when an arithmetic operation leads to a value that is greater than the maximum value that can be stored
    \item Affects most languages - even some managed languages, such as Java and C\#, are susceptible to integer overflow errors
    \item Exploiting integer overflow errors
          \begin{itemize}[nosep]
              \item calculating indexes into arrays
              \item calculating the amount of space to allocate for a buffer
              \item checking whether an overflow could occur
          \end{itemize}
\end{itemize}
\subsubsection*{Input Validation}
\begin{itemize}[nosep]
    \item Sources of input
          \begin{itemize}[nosep]
              \item user supplied files and terminal input
              \item command line arguments
              \item environment variables
              \item function calls from other modules
              \item network packets (web applications in detail later)
              \item \dots
          \end{itemize}
\end{itemize}
\subsubsection*{Format String Vulnerabilities}
\begin{itemize}
    \item Vulnerable functions
          \begin{itemize}[nosep]
              \item \mintinline{c}|sprintf|: writes to buffer
              \item \mintinline{c}|fprintf|: writes to file
              \item other members of the printf family (e.g. \mintinline{c}|snprintf|)
              \item \mintinline{c}|printk|: used in the Linux kernel
              \item other functions that use format strings (e.g. \mintinline{c}|syslog|)
          \end{itemize}
    \item Format placeholders
          \begin{itemize}[nosep]
              \item \mintinline{c}|%s| -- string
              \item \mintinline{c}|%d| -- number (output in decimal format)
              \item \mintinline{c}|%x| -- number (output in hexadecimal format)
              \item Special placeholder: \mintinline{c}|%n|
                    \begin{itemize}[nosep]
                        \item argument must be a pointer to a signed integer, where the number of characters printed so far will be written
                    \end{itemize}
          \end{itemize}
    \item When variable is printed directly, introduces Vulnerability
          \begin{itemize}[nosep]
              \item \mintinline{c}|printf(name)|;
              \item if \mintinline{c}|name| is provided as \mintinline{c}|%d%d%d| then the top three stack values will be printed
          \end{itemize}
    \item To prevent, use string formatting
          \begin{itemize}[nosep]
              \item \mintinline{c}|printf("%s%", name)|;
              \item if \mintinline{c}|name| is provided as \mintinline{c}|%d%d%d| then \mintinline{c}|"%d%d%d"| will be printed
          \end{itemize}
\end{itemize}
\subsubsection*{Race Conditions}
\begin{itemize}[nosep]
    \item Race condition
          \begin{itemize}[nosep]
              \item when results depend on the sequence or timing of uncontrollable events
              \item for example, when the output of a software depends on how the operating system schedules the execution of multiple processes or threads
          \end{itemize}
    \item Typically happens when interacting with
          \begin{itemize}[nosep]
              \item memory shared by multiple processes (or threads)
              \item file system
              \item signals and other interprocess communication mechanisms
          \end{itemize}
    \item Race condition bugs and errors
          \begin{itemize}[nosep]
              \item happen when events do not occur in the intended order
              \item typically very difficult to reproduce and debug
          \end{itemize}
    \item Attack approaches
          \begin{itemize}[nosep]
              \item try multiple times (if possible)
              \item slow down the target process
              \item increase computational load on the machine
              \item computational complexity attacks
          \end{itemize}
    \item Preventing Race Conditions
          \begin{itemize}
              \item Time of check to time of use
                    \begin{itemize}[nosep]
                        \item we cannot allow any changes in this interval
                        \item trying to make it short is not enough
                    \end{itemize}
              \item Prevention techniques
                    \begin{itemize}[nosep]
                        \item work with file descriptors instead of filenames
                        \item rely on filesystem access checks
                        \item be careful with directories that are writable by everyone (e.g. \texttt{/tmp/})
                        \item lock resources (files, databases, etc.)
                        \item look out for non-atomic operations (e.g. \mintinline{c}|num++|)
                        \item synchronization (e.g. semaphore, mutex)
                    \end{itemize}
          \end{itemize}
\end{itemize}
\section{Web vulnerabilities}
\subsubsection*{File Inclusion Vulnerabilities}
\begin{itemize}[nosep]
    \item Passing unvalidated user input to functions that load files
          \begin{itemize}[nosep]
              \item remote: webserver loads a file from another server
                    \begin{itemize}[nosep]
                        \item Attacker may run arbitrary PHP code on the vulnerable webserver
                        \item Prevention in PHP: disable allow\_url\_include
                              \begin{itemize}[nosep]
                                  \item disabled by default in newer versions
                                  \item prevents the inclusion of remote files
                              \end{itemize}
                    \end{itemize}
              \item local: webserver loads a local file
                    \begin{itemize}[nosep]
                        \item Directory traversal
                              \begin{itemize}[nosep]
                                  \item attacker may read any file (to which the webserver process has access)
                              \end{itemize}
                        \item Uploading PHP code to the webserver
                              \begin{itemize}[nosep]
                                  \item enables the attacker to execute arbitrary code on the webserver
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
    \item Susceptible functions in PHP:
          \begin{itemize}
              \item \mintinline{php}|include(file)|, \mintinline{php}|require(file)|, \mintinline{php}|include_once(file)|, \mintinline{php}|require_once(file)|
              \item parse the content of the specified file (anything between <?php and ?> is interpreted, anything outside is sent to the output)
              \item used to load PHP libraries, classes, etc.
          \end{itemize}
    \item Similar functions in other languages
    \item Prevention: do not trust user input at all
          \begin{itemize}[nosep]
              \item always validate input before using it
              \item do not use values directly (e.g. \mintinline{php}|switch| statement)
          \end{itemize}
\end{itemize}
\subsubsection*{File Upload Vulnerability}
\begin{itemize}
    \item File upload form
    \item Attacker may
          \begin{itemize}
              \item upload malicious PHP code \texttt{attack.php} $\rightarrow$ arbitrary code execution with \texttt{GET attack.php}
              \item upload, for example, \texttt{.htaccess} (per-directory configuration file for Apache webserver) $\rightarrow$ circumvent access control
              \item overwrite existing files
          \end{itemize}
\end{itemize}
\subsubsection*{Command Injection}
\begin{itemize}[nosep]
    \item Example: sendmail.php:
          \begin{minted}{php}
            <?php $address = $_GET["email"];
            system("mail $address -s 'Welcome to example.com!'< /var/www/welcome.txt");
            ?>
        \end{minted}
    \item exploit:
          \begin{itemize}[nosep]
              \item \texttt{GET sendmail.php?email=foo@bar.com; rm important\_file;} $\rightarrow$ \texttt{system("mail foo@bar.com; rm important\_file; -s \dots}
          \end{itemize}
\end{itemize}
\subsubsection*{SQL Injection Vulnerability}
\begin{itemize}[nosep]
    \item Attacker may execute any statement
          \begin{itemize}[nosep]
              \item delete an entire table: \texttt{'; DROP TABLE users; --}
              \item change the password of another user:
                    \texttt{'; UPDATE users SET password='pwnd' WHERE email = 'victim@example.com'; --}
          \end{itemize}
    \item Some databases even allow running system commands
          \begin{itemize}[nosep]
              \item example: Microsoft SQL Server \mintinline{sql}|xp_cmdshell|
          \end{itemize}
    \item Attempts to Prevent SQL Injection
          \begin{itemize}[nosep]
              \item Escape special characters
                    \begin{itemize}[nosep]
                        \item idea: add backslash \textbackslash before characters ', '', \textbackslash, and \texttt{NUL} to escape them
                        \item however, this is not as simple as it sounds
                    \end{itemize}
              \item Secret table and column names
                    \begin{itemize}[nosep]
                        \item attacker can guess and test them
                        \item most databases have queries for reading the database and table schema
                              \begin{itemize}[nosep]
                                  \item if query results are displayed, attacker can read the schema
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
    \item Preventing SQL Injection
          \begin{itemize}[nosep]
              \item \underline{Properly} escape special characters
              \item Object-relational mapping (ORM) framework
                    \begin{itemize}[nosep]
                        \item eliminates the need to develop potentially buggy and vulnerable custom code
                    \end{itemize}
              \item Prepared / parameterized SQL statements
                    \begin{itemize}[nosep]
                        \item execute the same query or statement repeatedly, only changing certain parameter values between the executions
                        \item advantageous for both performance and security
                              \begin{itemize}[nosep]
                                  \item statement needs to be parsed and optimized only once
                                  \item statement cannot be changed using SQL injection
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Cross-Site Scripting}
\begin{itemize}[nosep]
    \item A cross-site scripting (XSS) vulnerability enables an attacker to inject client-side script code into pages generated by a web server
          \begin{itemize}[nosep]
              \item attacker can use an XSS vulnerability to run malicious scripts on clients (i.e., web browsers) that view the webpage, and steal their private information, credentials, send requests in their name, etc.
              \item Types (note that there is also DOM-based XSS)
                    \begin{multicols}{2}
                        \item Stored XSS
                        \begin{itemize}[nosep]
                            \item attacker tricks the webserver into storing and serving a malicious script
                            \item malicious script is sent to clients visiting the webpage
                        \end{itemize}
                        \item Reflected XSS
                        \begin{itemize}[nosep]
                            \item attacker tricks a client into sending a specially crafted request to the server
                            \item malicious script is reflected back to the client as part of the response
                        \end{itemize}
                    \end{multicols}
          \end{itemize}
    \item Preventing XSS
          \begin{itemize}[nosep]
              \item Validate and filter all input data on the webserver
                    \begin{itemize}[nosep]
                        \item even if they are not processed by the webserver
                        \item some web browsers also try to detect reflected XSS by testing if a script received from the server was sent in the request
                    \end{itemize}
              \item Scripts may be specified in
                    \begin{itemize}[nosep]
                        \item script tag: \mintinline{html}|<script>|
                        \item event handlers: \mintinline{html}|onClick|, \mintinline{html}|onLoad|, \mintinline{html}|onSubmit|, \dots
                        \item \dots
                    \end{itemize}
              \item Remove or encode all special HTML characters
                    \begin{itemize}[nosep]
                        \item encoding: \texttt{\&lt;} instead of \texttt{<}, \texttt{\&quot;} instead of \texttt{''}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Cross-Site Request Forgery}
\begin{itemize}[nosep]
    \item A cross-site request forgery (CSRF) vulnerability enables an attacker to trick a user into sending malicious requests to a webpage
    \item Similar to reflected XSS, an attacker has many options for tricking the user into opening a malicious URL
          \begin{itemize}[nosep]
              \item sending link in e-mail or instant message
              \item displaying link on some other website
              \item \dots
          \end{itemize}
    \item Attackers might use a CSRF vulnerability to
          \begin{itemize}[nosep]
              \item open a backdoor on a server
              \item initiate a wire transfer on an online banking website
              \item \dots
          \end{itemize}
    \item May enable bypassing other access control methods
          \begin{itemize}[nosep]
              \item for example, if access to a server is limited to clients on the same local network
          \end{itemize}
    \item Prevention
          \begin{itemize}[nosep]
              \item Webserver has to verify that the request originates from a page belonging to the website (i.e., user ''clicked'' a link on the site, instead of opening a link from some other source)
              \item Techniques
                    \begin{itemize}[nosep]
                        \item synchronizer / secret token
                              \begin{itemize}[nosep]
                                  \item pages generated by the server include a secret input field
                                  \item when a user performs an action on the website, the value of the secret field is sent in the request $\rightarrow$ server can verify origin of the request
                              \end{itemize}
                        \item referrer validation
                              \begin{itemize}[nosep]
                                  \item HTTP requests may include a header field that identifies the address of the page that linked to the request resource
                                  \item however, referrer might be missing (or, in some cases, forged)
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\section{Malware}
\begin{itemize}[nosep]
    \item Malware (short for malicious software): software used to disrupt computer operations, gather sensitive information, or gain access to private systems
    \item Backdoor
          \begin{itemize}[nosep]
              \item secret entry point into a system or program that circumvents the usual security access procedures
              \item maintenance hook: legitimate use for debugging and testing
              \item asymmetric backdoor: can be used only by the developer, even if the implementation becomes public
              \item may be introduced by a malicious compiler
          \end{itemize}
    \item Logic bomb
          \begin{itemize}[nosep]
              \item code embedded in a legitimate program, which ''explodes'' when certain conditions are met (e.g. time, presence of some files, hostnames)
              \item may alter or delete data, system functionality, etc.
          \end{itemize}
    \item Trojan Horse
          \begin{itemize}[nosep]
              \item an apparently benign application that has some hidden malicious functionality
              \item Runs with and abuses the privileges of the victim user
              \item May implement various kinds of malicious functionality
              \item Typically spread using social-engineering techniques
                    \begin{itemize}
                        \item providing free (but illegal) copies of commercial software
                        \item sending as an e-mail attachment
                        \item drive-by download: authorized by the user without understanding the consequences
                    \end{itemize}
          \end{itemize}
    \item Virus
          \begin{itemize}
              \item parasitic self-replicating malware
              \item resident virus: remains in memory (e.g. as part of the OS), may overwrite interrupt handlers and other functions
              \item Infection targets
                    \begin{itemize}[nosep]
                        \item boot sector: targets the boot sector or Master Boot Record of the infected host's hard drive or removable media
                        \item executable files: targets binary executable files
                        \item documents (macro viruses): targets word processor and spreadsheet documents that support embedding macro programs (e.g. Microsoft Office)
                    \end{itemize}
              \item Typical phases of operation
                    \begin{enumerate}[nosep]
                        \item dormant: virus is waiting for an external event
                        \item propagation: virus places copies of itself into other executables and files
                        \item triggering: virus is activated by some external event
                        \item execution: virus executes the payload, which performs malicious actions
                    \end{enumerate}
          \end{itemize}
    \item Worm
          \begin{itemize}[nosep]
              \item runs independently, without a host program or file
              \item Propagates a copy of itself to other systems
                    \begin{itemize}[nosep]
                        \item typically by exploiting vulnerabilities, such as common software vulnerabilities or weak passwords
                        \item over the Internet, over a local computer network, or through removable media (e.g. USB flash drives)
                        \item e-mail worm: propagating as e-mail attachments
                    \end{itemize}
              \item Payload
                    \begin{itemize}[nosep]
                        \item either carried by the worm or downloaded from a server
                        \item may perform other tasks (e.g. spyware, ransomware, botnet)
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Spyware, Adware, Cryptojacking, Randomware}
\begin{itemize}[nosep]
    \item Spyware
          \begin{itemize}[nosep]
              \item collect sensitive information about the user
              \item may record keystrokes, mouse clicks, browsing activity, etc.
              \item attacker can use it to collect personal information (e.g. social security number, financial information, such as credit card numbers)
          \end{itemize}
    \item Adware
          \begin{itemize}[nosep]
              \item display unwanted advertisement to the user (e.g. pop-up windows, injecting into web pages, ...)
              \item legitimate use: advertisement-supported non-malicious software
          \end{itemize}
    \item Cryptojacking
          \begin{itemize}[nosep]
              \item use the infected computer's resources to ''mine'' proof-of-work cryptocurrencies (e.g., Bitcoin) for the attacker
          \end{itemize}
    \item Ransomware
          \begin{itemize}
              \item holds a computer system or data hostage
              \item disables access to the computer system or certain files on it (e.g., screen locking, browser locking)
              \item may also threaten to publish the victim's files online
              \item ''scareware'': threaten or deceive users (e.g., fake antivirus)
              \item Payment
                    \begin{itemize}[nosep]
                        \item computer system or data is released upon payment
                        \item payment through Bitcoin, premium-rate text messages, wire transfers, etc.
                    \end{itemize}
              \item Crypto-ransomware
                    \begin{enumerate}[nosep]
                        \item ransomware encrypts files using a random symmetric key
                        \item symmetric key is encrypted using the attacker's public key and then deleted
                        \item attacker decrypts the symmetric key in exchange for payment
                    \end{enumerate}
          \end{itemize}
\end{itemize}
\subsubsection*{Botnets}
\begin{itemize}[nosep]
    \item collection of computers controlled through the Internet
          \begin{itemize}[nosep]
              \item legal application: distributed computing
              \item illegal application: taking advantage of compromised ``zombie'' computers
          \end{itemize}
    \item Zombie computers
          \begin{itemize}[nosep]
              \item laptop and desktop computers
              \item IoT devices (e.g., remote cameras, home routers, DVRs)
          \end{itemize}
    \item Typically used by attackers to
          \begin{itemize}[nosep]
              \item send spam e-mail or perform click fraud
              \item collect personal information $\approx$ spyware
              \item attack other systems (e.g., denial-of-service attack by flooding with requests)
          \end{itemize}
    \item Architectures
          \begin{multicols}{2}
              \begin{itemize}[nosep]
                  \item Client-Server
                        \begin{itemize}[nosep]
                            \item publish digitally signed commands on
                                  websites, IRC channels, or other standard protocols
                            \item C\&C servers are typically redundant, and often implemented on compromised computers
                        \end{itemize}
                  \item Peer-to-Peer
                        \begin{itemize}[nosep]
                            \item commands distributed over a peer-to-peer (P2P) network
                            \item no single (or few) point of failure $\rightarrow$ more resilient to shutdown or hijack
                        \end{itemize}
              \end{itemize}
          \end{multicols}
\end{itemize}
\subsubsection*{Rootkit}
\begin{itemize}[nosep]
    \item enables unauthorized access to a computer system
    \item hides its own existence
    \item Typically installed by attackers after compromising a system
          \begin{itemize}[nosep]
              \item provides backdoor for easy reentry
              \item keeps the compromise hidden from operators $\rightarrow$ persistent and stealthy compromise
          \end{itemize}
    \item Installation
          \begin{itemize}[nosep]
              \item typically requires root (or administrator) access
              \item may be performed manually or automatically
          \end{itemize}
    \item Techniques for hiding
          \begin{itemize}[nosep]
              \item Rootkit must be installed and run on the compromised system $\rightarrow$ without hiding, it might be visible as a file or running process
              \item Modifying system commands and applications
                    \begin{itemize}[nosep]
                        \item ls: lists files in a directory $\rightarrow$ modify to omit the rootkit files
                        \item ps: lists running processes $\rightarrow$ modify to omit the rootkit proce
                    \end{itemize}
              \item Modifying or disabling event logging
                    \begin{itemize}[nosep]
                        \item system logs may provide evidence of an attack $\rightarrow$ remove log entries
                    \end{itemize}
              \item Disabling anti-virus and anti-rootkit software
              \item Modifying the kernel, system drivers, and other core parts of the OS
                    \begin{itemize}[nosep]
                        \item rootkits may tamper with any system call, security mechanism, etc.
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Malware Detection}
\begin{itemize}[nosep]
    \item ``Arms race'' between malware scanners and concealment techniques
    \item Signature-based malware scanner: detects known viruses based on patterns
    \item Polymorphic malware: ''mutates'' (i.e., changes) itself to avoid signature-based detection
    \item Encrypted malware
          \begin{itemize}[nosep]
              \item common technique for polymorphic malware
              \item most of the malware is encrypted, except for a short code that can decrypt it
              \item decryption code must be in plaintext $\rightarrow$ signature for self-decryption (very rare for non-malicious software)
          \end{itemize}
    \item Metamorphic malware: changes the entire code upon each infection (including, e.g., decryption code)
    \item Heuristic rule-based malware scanner: identify code fragments commonly used by malware
    \item Behavior-based malware detection: detect behavior characteristic to malware (e.g., sending data to C\&C servers)
    \item White-list known good programs, verify integrity
\end{itemize}
\section{Secure development}
\subsubsection*{compile-time buffer-overflow prevention}
\begin{itemize}[nosep]
    \item Programming Languages and platforms that do not allow direct memory access typically prevent buffer overflows
          \begin{itemize}[nosep]
              \item C\# and other managed .NET languages
              \item Java, Python, PHP, Perl
              \item However,
                    \begin{itemize}[nosep]
                        \item safety and security may come at the cost of lower performance (bounds checking can increase execution time)
                        \item native code invoked from these languages is still vulnerable (e.g. through Java Native Interface)
                        \item be careful with libraries that might rely on native code
                        \item there might be vulnerabilities in the interpreter/virtual machine of the language (e.g., JVM or CLR)
                    \end{itemize}
          \end{itemize}
    \item Safe Functions
          \begin{table}[H]
              \begin{tabular}{ll}
                  Unsafe                                                        & Less unsafe                                                               \\\toprule
                  \multirow{2}{*}{\mintinline{c}|strcpy(char *src, char *dst)|} & \mintinline{c}|strncpy(char *src, char *dst, size_t n)| (not really safe) \\
                                                                                & \mintinline{c}|strlcpy(char *src, char *dst, size_t n)|                   \\\midrule
                  \multirow{2}{*}{\mintinline{c}|strcat(char *s1, char *s2)|}   & \mintinline{c}|strncat(char *s1, char *s2, size_t n)|                     \\
                                                                                & \mintinline{c}|strlcat(char *s1, char *s2, size_t n)|                     \\\midrule
                  \mintinline{c}|sprintf(char *str, char* format, ...)|         & \mintinline{c}|snprintf(char *str, size_t n, char* format, ...)|          \\\midrule
                  \mintinline{c}|gets(char *str)|                               & \mintinline{c}|fgets(char *str, int n, FILE *file)|                       \\\bottomrule
              \end{tabular}
          \end{table}
    \item Safe Libraries
          \begin{itemize}[nosep]
              \item e.g. String class \mintinline{c++}|std::string|; mostly safe, but \mintinline{c++}|[]| operator can cause issues
              \item same with Array class \mintinline{c++}|std::vector|
          \end{itemize}
    \item Stack Canary Compiler Extension
          \begin{itemize}[nosep]
              \item at the beginning of the function, a special value is placed on the stack between the local variables and the return address
              \item buffer overflows that reach the return address will necessarily overwrite the special value
              \item before returning, the function checks if the value is intact
          \end{itemize}
\end{itemize}
\subsubsection*{Secure Programming/Defensive Programming}
\begin{itemize}[nosep]
    \item Techniques and approaches for improving the source code
    \item Avoiding typical errors that lead to common vulnerabilities
    \item assume nothing (e.g., input length)
    \item expect everything (e.g., errors and misuse)
    \item i.e., ``be paranoid''
    \item Use safe functions (e.g., never use \mintinline{c}|gets|, use \mintinline{c}|fgets| instead), use safe libraries
    \item Do not use input in vulnerable functions directly (e.g. file inclusion, string output)
    \item Beware integer type conversions and promotion
    \item Do not allow changes between time of check and time of use to prevent race condition vulnerabilities
    \item Use prepared statements for SQL queries
    \item Sanitize user input before sending it to other systems (e.g., XSS)
    \item Validate the sources of HTTP requests to prevent CSRF
    \item \dots
\end{itemize}
\subsubsection*{Input Validation}
\begin{multicols}{2}
    \begin{itemize}
        \item blacklist
              \begin{itemize}[nosep]
                  \item list known bad inputs
                  \item do not allow inputs that are on the blacklist
                  \item listing all bad inputs is difficult and error-prone\vfill\null
                  \item typically has low impact on usability
              \end{itemize}
        \item whitelist
              \begin{itemize}[nosep]
                  \item list known good inputs
                  \item allow only inputs that are on the whitelist
                  \item typically more secure
              \end{itemize}
    \end{itemize}
\end{multicols}
\subsubsection*{Code Analysis}
\begin{itemize}
    \begin{multicols}{2}
        \item static
        \begin{itemize}[nosep]
            \item input: typically source code
            \item finds vulnerabilities by considering possible executions of the source code
            \item typically ``white-box'' approach
        \end{itemize}
        \item dynamic
        \begin{itemize}[nosep]
            \item input: typically binary (compiled) code
            \item finds vulnerabilities by executing the code with various inputs
            \item typically ``black-box'' approach
        \end{itemize}
    \end{multicols}
    \item Static analysis may find the root cause of a problem, while dynamic analysis can detect only when the problem occurs
\end{itemize}
\subsubsection*{Taint Analysis}
\begin{itemize}[nosep]
    \item attempts to identify which variables and objects can be modified by untrusted user input
          \begin{itemize}[nosep]
              \item if the source of the value of a variable is untrustworthy (e.g., network packets, user files, user input), then the variable is tainted
              \item any variable whose value is derived from (e.g., through mathematical or string operators) from a tainted variable is also tainted
              \item tainted variable passed to a vulnerable function without sanitization $\rightarrow$ potential software vulnerability
          \end{itemize}
    \item Information flow analysis
          \begin{itemize}[nosep]
              \item assign a security level to each source
              \item each object inherits the security levels of the sources and other objects from which it is derived
              \item may be used to detect the leakage of confidential information
          \end{itemize}
    \item In practice
          \begin{itemize}[nosep]
              \item static: analyze source code $\rightarrow$ rewrite source code if vulnerability is found
              \item dynamic: keep track of tainted variables during run time $\rightarrow$ throw an exception
          \end{itemize}
\end{itemize}
\section{Detection}
\section{Isolation}
\section{Denial of Service attacks}
\section{Vulnerability scanners}
\end{document}
