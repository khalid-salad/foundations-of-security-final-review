\documentclass[final]{article}
\usepackage{final-review}
\begin{document}
\include{titlepage}
\section{Advanced crypto}
\subsection{Advanced Cryptographic Primitives}
\begin{itemize}[nosep]
    \item secure multiparty computation
    \item homomorphic encryption
\end{itemize}
\subsection{Commitment Schemes}
\subsubsection*{Commitment Problem}
\begin{itemize}[nosep]
    \item Bob “calls” the coin flip (i.e., heads or tails)
    \item Alice flips the coin
    \item Bob wins if her call is correct, Alice wins otherwise
\end{itemize}
Can we prevent Alice from cheating even if the players are not in the same physical location?

\subsubsection*{Commitment Scheme}
\begin{itemize}[nosep]
    \item Two phases
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ chooses a value $V$, $A$ sends a \textbf{commitment} of $V$ to $B$
              \item \underline{reveal}: $A$ reveals the value of $V$
          \end{enumerate}
    \item Example: coin flipping
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ flips a coin, $A$ sends a commitment (i.e., coin is heads or tails) to $B$
          \end{enumerate}
          \begin{itemize}[nosep]
              \item $B$ calls the coin flip (i.e., heads or tails)
          \end{itemize}
          \begin{enumerate}[resume,nosep]
              \item \underline{reveal}: $A$ reveals the value of the coin flip
          \end{enumerate}
    \item Requirements for commitment scheme
          \begin{itemize}[nosep]
              \item $B$ cannot learn the value of $V$ from the commitment
              \item $A$ can reveal only the originally chosen value for a commitment
          \end{itemize}
\end{itemize}
\subsubsection*{Naive Attempt Using Hash Function}
\begin{itemize}[nosep]
    \item $H$: cryptographic hash function
    \item If the set of possible values of $V$ are small (e.g., ``heads'' or ``tails''), $B$ can learn $V$ by simply trying all possible values
\end{itemize}
\subsubsection*{Secure Commitment Using Hash Function}
\begin{itemize}[nosep]
    \item Collision-free hash function $\rightarrow$ $A$ cannot cheat by finding $V_1$ and $V_2$ such that $H(r_1 \mid r_2 \mid V_1) = H(r_1 \mid r_2 \mid V_2)$
          \begin{itemize}
              \item $r_1$ prevents pre-computation of colliding $V_1$ and $V_2$
          \end{itemize}
\end{itemize}
\subsection{Secret Sharing}
\begin{itemize}[nosep]
    \item \underline{Problem}: distribute a secret among $N$ participants such that
          \begin{itemize}[nosep]
              \item any group of at least $T$ participants can reconstruct the secret
              \item no group of fewer than $T$ participants can reconstruct any part of it
          \end{itemize}
    \item Types
          \begin{itemize}[nosep]
              \item \textbf{unconditionally secure}: information-theoretically secure (unbounded attacker)
              \item \textbf{conditionally secure}: typically more efficient
          \end{itemize}
\end{itemize}
\subsubsection*{Special Case: $T = N$}
\begin{itemize}[nosep]
    \item Unconditionally secure scheme:
          \begin{enumerate}[nosep]
              \item let the secret be a binary number $S$
              \item pick $N - 1$ random numbers $R_1$, $R_2$, \dots, $R_{N-1}$ of the same length
              \item give each participant $i$, $i < N$, the number $R_i$
              \item give the last participant the result of $S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}$
          \end{enumerate}
    \item $N$ participants can reconstruct the secret by XORing their numbers:
          \begin{itemize}[nosep]
              \item \begin{align*}&R_1 \xor R_2 \xor \dots \xor R_{N-1} \xor \left(S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}\right) \\&= (R_1 \xor R_1) \xor (R_2 \xor R_2) \xor \dots \xor (R_{N-1} \xor R_{N-1}) \xor S \\&= S\end{align*}
          \end{itemize}
    \item $N - 1$ participants can compute only $S \xor R_i$, where $i$ is the missing participant (or $R_1 \xor R_2 \xor \dots \xor R_{N-1}$ if the last participant is missing)
\end{itemize}
\subsection{Shamir's Secret Sharing}
\begin{itemize}[nosep]
    \item Proposed by Shamir in 1979
    \item Unconditionally secure
    \item Special case $T=2$
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random number $A$
              \item let each participant's share be a random point on the line $Ax + S$
          \end{enumerate}
          \begin{multicols}{2}
              \begin{figure}[H]
                  \begin{tikzpicture}
                      \begin{axis}[xlabel = $x$, ylabel=$y$, ticks=none, ymax=10]
                          \addplot[color=red,thick]{0.8 * x + 1};
                          \addlegendentry{$Ax + S$}
                          \draw[black] (0, 1) circle (2pt) node [right] {$(x_i, y_i)$};
                          \draw[black] (-3, -1.4) circle (2pt) node [right] {};
                          \draw[black] (3, 3.4) circle (2pt) node [right] {};
                      \end{axis}
                  \end{tikzpicture}
              \end{figure}
              \item $T = 2$ participants can reconstruct the secret since any two points define a line
              \item Single participant cannot learn the slope
          \end{multicols}
\end{itemize}
\subsubsection*{General Case}
\begin{itemize}[nosep]
    \item Arbitrary T:
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random numbers $A_1$, $A_2$, $\dots$, $A_{T-1}$
              \item let each participant's share be a random point from the curve
                    \[y = S + A_1 x + A_2 x^2 + \dots + A_{T-1}x^{T-1}\]
          \end{enumerate}
    \item At least $T$ points are necessary to define a polynomial of degree $T - 1$
    \item Example $T = 3$
          \begin{itemize}[nosep]
              \item secret is a parabola (i.e., $A_2 x^2 + A1 x + S$)
              \item there an infinite number of parabolas fitting two points
              \item but three point define one uniquely
          \end{itemize}
\end{itemize}
\subsection{Secure Multiparty Computation}
\begin{itemize}[nosep]
    \item \underline{Problem}: $N$ participants with private data $d_1$, $d_2$, \dots, $d_N$
          \begin{itemize}[nosep]
              \item participants would like to compute the value $F(d_1, d_2, \dots, d_N)$ of a public function $F$ over their private data
              \item no participant $i$ would like to reveal any information about its data $d_i$
          \end{itemize}
    \item Requirements
          \begin{itemize}
              \item \textbf{privacy}: no information is revealed about any private data (other than what is revealed by the public output)
              \item \textbf{correctness}: public function is correctly computed
          \end{itemize}
    \item Adversaries may be semi-honest (passive) or malicious (active)
\end{itemize}
\section{WiFi security}
\subsection{Security Challenge}
\begin{itemize}[nosep]
    \item \underline{Problem}: no inherent physical protection
    \item \textbf{joining} a network does not require physical access
    \item radio transmissions are broadcast $\rightarrow$ anyone in range can \textbf{eavesdrop}
    \item \textbf{injecting} new messages or \textbf{replaying} old messages is possible
    \item \textbf{jamming} attacks against availability
    \item jamming and injecting messages can be combined into \textbf{tampering} attacks
\end{itemize}
\subsection{Simple “Solutions” for Access Control}
\subsubsection*{Hidden SSID}
\begin{itemize}[nosep]
    \item Association request must contain the SSID of the network
          \begin{itemize}[nosep]
              \item by default, the AP broadcasts it periodically in the beacon
          \end{itemize}
    \item AP may be configured to \textbf{stop announcing the SSID} $\rightarrow$ SSID may be be used as a ``password''
    \item However,
          \begin{itemize}[nosep]
              \item SSID must be hard to guess
              \item every authorized user must know the SSID
              \item \textbf{SSID can be easily eavesdropped} whenever an authorized station connects to the network $\rightarrow$ does not provide any security
          \end{itemize}
    \item Tools are available for eavesdropping (e.g. Aircrack-ng)
\end{itemize}
\subsubsection*{MAC Address Based Filtering}
\begin{itemize}[nosep]
    \item AP may be configured to \textbf{allow only devices with certain MAC addresses} to connect
          \begin{itemize}[nosep]
              \item MAC addresses of all authorized devices must be registered in advance
          \end{itemize}
    \item However,
          \begin{itemize}[nosep]
              \item \textbf{MAC address is sent in plaintext} in every packet
              \item many WLAN devices allow their MAC addresses to be changed $\rightarrow$ attacker can easily impersonate an authorized user
          \end{itemize}
\end{itemize}
\subsection{802.11 Security Standards}
\subsubsection*{WEP}
\begin{itemize}
    \item security is based on a 40 or 104-bit secret key
          \begin{itemize}[nosep]
              \item WiFi “password” shared by all users
          \end{itemize}
    \item \underline{confidentiality}: RC4 stream cipher
          \begin{itemize}[nosep]
              \item key is extended by a 24-bit IV, which is changed for each message $\rightarrow$ used as nonce to prevent key reuse problems
          \end{itemize}
    \item \underline{integrity}: encrypted CRC32 (Cyclic Redundancy Check) checksum
    \item \underline{access control}: challenge-response between AP and station
\end{itemize}
\subsubsection*{WEP Design Flaws}
\begin{itemize}[nosep]
    \item Authentication
          \begin{itemize}[nosep]
              \item \textbf{one-way authentication} (only for station) $\rightarrow$ AP can be impersonated
          \end{itemize}
    \item Integrity protection
          \begin{itemize}[nosep]
              \item based on \textbf{error-detection code} (CRC32) instead of cryptographic hash $\rightarrow$ forging authentication tags is trivial
              \item \textbf{no message replay protection}
          \end{itemize}
    \item Key usage
          \begin{itemize}
              \item \textbf{no session key}: long-term key used for all purposes (authentication, encryption, integrity protection)
              \item \textbf{short nonce} (i.e., 24-bit IV) $\rightarrow$ danger of key reuse for stream cipher
                    \begin{itemize}[nosep]
                        \item busy network with 1000 packets per second reuses in less than 5 hours
                    \end{itemize}
              \item vulnerable to Fluhrer-Mantin-Shamir Attack
                    \begin{itemize}[nosep]
                        \item In practice, WEP keys can be broken in a matter of minutes (or less) $\rightarrow$ WEP is \textbf{not secure}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsection{WiFi Protected Access (WPA)}
\subsubsection*{WPA}
\begin{itemize}[nosep]
    \item Standard: 802.11i TKIP (Temporal Key Integrity Protocol
    \item Design goals: \textbf{fix the flaws of WEP} and be \textbf{compatible with legacy hardware}
    \item Overview
          \begin{itemize}
              \item \underline{key usage}: session key is established during a secure two-way authentication
              \item \underline{confidentiality}: RC4 encryption, but with \textbf{48-bit IV}, which is \textbf{mixed thoroughly} with the session key and source MAC address
                    \begin{itemize}[nosep]
                        \item prevents key reuse and the Fluhrer-Mantin-Shamir attack
                    \end{itemize}
              \item \underline{integrity}: 64-bit message integrity codes computed using Michael, which is \textbf{computationally very efficient} but provides only ~20 bits of effective security
                    \begin{itemize}[nosep]
                        \item after wrong code, station is banned for a minute and needs to re-authenticate
                    \end{itemize}
              \item Deprecated in later revisions of the standard
          \end{itemize}
\end{itemize}
\begin{itemize}
    \item
\end{itemize}
\subsubsection*{WPA-2}
\begin{itemize}[nosep]
    \item Standard: \textbf{IEEE 802.11i}
    \item WPA 2 Devices can be certified by the Wi-Fi Alliance
\end{itemize}
\subsubsection*{Phases}
\begin{enumerate}[nosep]
    \item Discovery
          \begin{itemize}
              \item agree on what authentication method and ciphers to use
          \end{itemize}
    \item Authentication
          \begin{itemize}[nosep]
              \item may use an authentication server
              \item create a master session key
          \end{itemize}
    \item Key management
          \begin{itemize}[nosep]
              \item derive keys for various purposes
          \end{itemize}
    \item Protected data transfer
    \item Connection termination
\end{enumerate}
\subsubsection*{Discovery Phase}
\begin{itemize}[nosep]
    \item \underline{Goal}: station and AP may support different sets of authentication methods and ciphers $\rightarrow$ they need to agree on which ones they will use
    \item \textbf{Authentication and key-management suite}: how to perform mutual authentication and derive fresh keys
          \begin{itemize}[nosep]
              \item IEEE 802.1X, pre-shared key (PSK), or vendor-specific
          \end{itemize}
    \item \textbf{Cipher suite}: what ciphers to use for confidentiality and integrity
          \begin{itemize}
              \item WEP, TKIP, CCMP, or vendor-specific
          \end{itemize}
    \item Protocol
          \begin{enumerate}[nosep]
              \item AP can periodically \textbf{broadcast} its security capabilities using a \textbf{Beacon} (or station can ask for it using a Probe Request message)
              \item Station \textbf{specifies} an authentication and cipher suite in an \textbf{Association Request}
              \item if the AP \textbf{accepts} the specified suites, it sends an \textbf{Association Response}
          \end{enumerate}
\end{itemize}
\subsubsection*{Authentication Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item mutual authentication:
                    \begin{enumerate}[nosep, label=\arabic*)]
                        \item only authorized stations can use the network
                        \item station is assured that it communicates with a legitimate network
                    \end{enumerate}
              \item generate \textbf{pairwise master key} (PMK)
          \end{itemize}
    \item Approaches
          \begin{itemize}[nosep]
              \item Pre-shared key (PSK)
                    \begin{itemize}[nosep]
                        \item password is deployed on each station and the AP manually
                        \item PMK = PSK = generated from the password using a hash function
                        \item ideal for home and small office networks
                    \end{itemize}
              \item IEEE 802.1X
          \end{itemize}
\end{itemize}
\subsubsection*{Key-Management Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item derive \textbf{pairwise transient keys} from the PMK
              \item distribute \textbf{group keys}
          \end{itemize}
    \item Pairwise transient key (PTK)
          \begin{itemize}[nosep]
              \item protecting data between station and AP
              \item generated from PMK and the AP's and station's MAC addresses and nonces
          \end{itemize}
    \item Group temporal key (GTK)
          \begin{itemize}[nosep]
              \item protecting multicast communication
              \item group master key (GMK): generated randomly by the AP
              \item distributed using the PTK
          \end{itemize}
\end{itemize}
\subsubsection*{Protected Data Transfer Phase}
\begin{itemize}[nosep]
    \item Standard defines two schemes: TKIP and CCMP
    \item TKIP: see WPA
    \item CCMP (Counter mode CBC-MAC Protocol)
          \begin{itemize}[nosep]
              \item based on the CCM (Counter with CBC-MAC) authenticated encryption mode
              \item integrity: CBC-MAC based on AES encryption
              \item confidentiality: AES encryption in counter (CTR) mode
              \item same 128-bit key for integrity and confidentiality (from PTK)
              \item 48-bit packet number to prevent replay attacks
          \end{itemize}
\end{itemize}
\subsubsection*{IEEE 802.1X}
\begin{itemize}[nosep]
    \item Standard for port-based network access control
    \item Entities
          \begin{itemize}[nosep]
              \item supplicant = station
              \item authenticator = access point
              \item authentication server
          \end{itemize}
    \item Port-based: supplicant can access only the authentication server until the authentication succeeds
    \item Authentication server does not have to be implemented on the access point $\rightarrow$ little overhead for the access point
\end{itemize}
\subsubsection*{EAP Authentication Methods}
\begin{itemize}[nosep]
    \item Extensible framework, not a specific authentication mechanism
    \item Example methods
          \begin{itemize}[nosep]
              \item EAP-TLS: based on public-key certificates
              \item EAP-GPSK (Generalized Pre-Shared Key): based on secret keys shared by the client and the server, uses symmetric-key cryptography
          \end{itemize}
\end{itemize}
\section{IPSec}
\begin{itemize}[nosep]
    \item Collection of protocols and mechanisms, standardized by the Internet Engineering Task Force (IETF) in a series of publications
    \item Provides
          \begin{itemize}[nosep]
              \item data confidentiality and integrity
              \item source authentication (prevent address spoofing, i.e., sending from fake address)
              \item protection against packet replay
          \end{itemize}
    \item Below the transport layer (TCP or UDP) $\rightarrow$ transparent to applications
    \item End-to-end security between two hosts, a host and a network, or between two networks
    \item Example Applications of IPSec
          \begin{itemize}[nosep]
              \item Secure remote access over the Internet
              \item Secure virtual private network
          \end{itemize}
\end{itemize}
\subsection{Transport Mode and Tunnel Mode}
\begin{itemize}[nosep]
    \item Transport mode
          \begin{itemize}[nosep]
              \item protects the payload of the IP packet
              \item typically host-to-host communication
          \end{itemize}
    \item Tunnel mode
          \begin{itemize}[nosep]
              \item protects the entire IP packet by encapsulating it in the payload of a new IP packet
              \item typically host-to-network or network-to-network communication
          \end{itemize}
\end{itemize}
\begin{table}[H]
    \begin{tabular}{lll}
        \multicolumn{3}{c}{Protocol}                                                                             \\
                 & Authentication Headher (AH)                   & Encapsulating Security Payloads (ESP)         \\\toprule
        Modes    & \multicolumn{2}{c}{both transport and tunnel}                                                 \\
        Provides & integrity, replay protection                  & integrity, confidentiality, replay protection \\
        Protects & payload and IP header                         & payload                                       \\\bottomrule
    \end{tabular}
\end{table}
\subsubsection*{Authentication Header}
\begin{itemize}[nosep]
    \item Services
          \begin{itemize}[nosep]
              \item data and origin integrity
              \item replay-prevention
          \end{itemize}
    \item Message authentication
          \begin{itemize}[nosep]
              \item computed from immutable fields of the IP header, AH header (except ICV), and original payload
              \item algorithms: HMAC-MD5, HMAC-SHA-1, HMAC-SHA-2, \dots
          \end{itemize}
\end{itemize}
\subsubsection*{Encapsulating Security Payload}
\begin{itemize}[nosep]
    \item Services: confidentiality, integrity (optional), replay prevention
    \item Encryption: AES-CBC, 3DES-CBC, \dots
    \item Message authentication: HMAC-SHA-1, AES-GMAC, \dots
    \item Authenticated encryption: AES-GCM
\end{itemize}
\subsubsection*{Combining Modes and Protocols}
\begin{itemize}[nosep]
    \item Tunnel mode advantage: requires support only at the gateways
    \item Transport mode advantage: requires support only at the hosts
    \item AH advantage: authenticates some elements of the original header
    \item ESP advantage: protects both integrity and confidentiality
    \item Combining modes
          \begin{itemize}[nosep]
              \item IPSec tunnel can carry any IP packet $\rightarrow$ IPSec transport or tunnel packets can be sent through an IPSec tunnel
              \item IPSec transport can protect any IP packet $\rightarrow$ IPSec transport or tunnel packets can be protected by outer IPSec transport
              \item \dots
              \item can be nested to any depth
          \end{itemize}
    \item Combination Examples
          \begin{enumerate}[nosep]
              \item AH in transport (for integrity) + ESP in transport (for confidentiality)
              \item IPSec packets over tunnel
          \end{enumerate}
\end{itemize}
\section{SSL / TLS}
\subsubsection*{Secure Socket Layer}
\begin{itemize}[nosep]
    \item End-to-end security between two applications
    \item Endpoint applications can implement it without the help of the operating systems or any intermediate devices
    \item Developed by Netscape for securing HTTP $\rightarrow$ HTTPS = HTTP over SSL
    \item very widely used, not just for HTTP (e.g., FTP, POP3, IMAP)
\end{itemize}
\subsubsection*{Overview}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,rectangle,fill=gray!40,node distance=0cm,minimum height=1.5cm, minimum width=2cm}]
        \node (handshake) {SSL\\Handshake\\Protocol};
        \node[right=of handshake] (cipher) {SSL Change\\Cipher Spec\\Protocol};
        \node[right=of cipher] (alert) {SSL Alert\\Protocol};
        \node[right=of alert] (http) {HTTP};
        \path (handshake.south west) rectangle ([yshift=-1.5cm]http.south east) node[pos=0.5,minimum width=8.15cm] (record) {SSL Record Protocol};
        \path (record.south west) rectangle ([yshift=-1.5cm]record.south east) node[pos=0.5,minimum width=8.15cm] (tcp) {TCP};
        \path (tcp.south west) rectangle ([yshift=-1.5cm]tcp.south east) node[pos=0.5,minimum width=8.15cm] (ip) {IP};

        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=handshake, node distance=4cm] (negotiation) {algorithm negotiation,\\key exchange,\\authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=record, node distance=7cm] (encryption) {encryption and\\message authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,above of=cipher, node distance=2cm] (switch) {switching algorithms\\and keys};
        \node[minimum size=0cm,inner sep=-0.05cm,fill=none,draw=none,above of=http,node distance=2cm] (sending) {sending SSL related\\alerts, which may\\terminate the connection};

        \draw[->] (negotiation.north east) to[bend left] ([xshift=0.5cm,yshift=0.1cm]handshake.north west);
        \draw[->] (encryption.north east) to[bend left] (record.west);
        \draw[->] (switch.south) to ([yshift=0.1cm]cipher.north);
        \draw[->] (sending.south west) to[bend right] ([xshift=0.5cm,yshift=0.1cm]alert.north west);
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSL Record Protocol}
\begin{itemize}[nosep]
    \item Security 528
          \begin{itemize}[nosep]
              \item confidentiality: symmetric-key encryption (AES GCM, Salsa20, \dots)
              \item integrity: message authentication codes based on symmetric-key cryptography (HMAC-SHA256, \dots)
          \end{itemize}
    \item Additional Services
          \begin{itemize}[nosep]
              \item fragmentation: fragment application data into records of at most 16 KiB
              \item lossless compression: optional (default is no compression)
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Handshake Protocol}
\begin{itemize}[nosep]
    \item Phase 1: establish security capabilities
          \begin{itemize}[nosep]
              \item client\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by the client
                        \item nonce (timestamp + random value)
                        \item cipher suite: list of key-exchange methods, as well as encryption and MAC algorithms
                        \item compression method: list of supported compression algorithms
                    \end{itemize}
              \item server\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by both the
                              client and the server
                        \item nonce
                        \item chosen cipher suite and compression method
                    \end{itemize}
          \end{itemize}
    \item Phase 2: server authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate (may be a chain)
              \item server\_key\_exchange (optional):
                    \begin{itemize}[nosep]
                        \item parameters for Anonymous or Ephemeral Diffie-Hellman exchange
                        \item public-key for RSA exchange if the certificate contains only a signing key
                        \item signed by the server (together with the nonces)
                    \end{itemize}
              \item certificate\_request (optional): ask client for an X.509 certificate
              \item server\_hello\_done: server is finished
          \end{itemize}
    \item Phase 3: client authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate if the server asked for a client certificate
              \item client\_key\_exchange:
                    \begin{itemize}[nosep]
                        \item pre-master secret encrypted using public RSA key of the server
                        \item parameters for D-H exchange
                    \end{itemize}
              \item certificate\_verify (optional): digital signature of all previous handshake messages
          \end{itemize}
\end{itemize}
\subsubsection*{Key Exchange Methods}
\begin{itemize}[nosep]
    \item Goal: exchange or agree on a pre-master secret (PMS)
    \item RSA
          \begin{itemize}[nosep]
              \item client generates pre-master secret (PMS)
              \item sends PMS to the server encrypted using RSA public-key encryption
          \end{itemize}
    \item Diffie-Hellman protocol
          \begin{itemize}[nosep]
              \item anonymous D-H: basic D-H with no authentication
              \item fixed D-H: D-H parameters of the server ($X_A$ and $Y_A$) are fixed and $Y_A$ is contained in a digital certificate
              \item ephemeral D-H: D-H with authentication
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Change Cipher Spec Protocol}
\begin{itemize}[nosep]
    \item Same for client and server
          \begin{itemize}[nosep]
              \item change\_cipher\_spec: signals that the communication party is switching to the negotiated cryptographic algorithms and keys
              \item finished: hash value computed from the master secret and all handshake messages using HMAC with SHA hash function
          \end{itemize}
\end{itemize}
\subsubsection*{Session Resume}
\begin{itemize}
    \item Authentication and key exchange are complex $\rightarrow$ result needs to be reusable
    \item Session
          \begin{itemize}[nosep]
              \item association between a client and a server
              \item cipher suite, compression method, and master secret
          \end{itemize}
    \item Connection
          \begin{itemize}[nosep]
              \item within a session
              \item keys and IVs for encryption and message authentication
          \end{itemize}
    \item Session ID: identifies a session
          \begin{itemize}[nosep]
              \item sent in ClientHello $\rightarrow$ may specify an existing session to be resumed
              \item sent in ServerHello $\rightarrow$ server can accept resume by sending the same ID
          \end{itemize}
    \item Session resume skips all messages in the Handshake after the ClientHello and ServerHello messages
          \begin{itemize}[nosep]
              \item new keys and IVs are generated from the nonces in the Hello messages
          \end{itemize}
\end{itemize}

\subsubsection*{Transport Layer Security}
\begin{itemize}[nosep]
    \item only minor differences compared to SSL 3.0:
          \begin{itemize}[nosep]
              \item pseudorandom function for generating keys and MAC is based on HMAC
              \item variable length padding (may prevent traffic analysis)
              \item other minor changes
          \end{itemize}
\end{itemize}
\subsubsection*{HTTPS}
\begin{itemize}[nosep]
    \item HTTP over SSL/TLS
    \item Between the web browser and server:
          \begin{itemize}[nosep]
              \item HTTP client = SSL client
              \item HTTP server = SSL server
          \end{itemize}
    \item Conventions
          \begin{itemize}[nosep]
              \item URL: \texttt{http\textbf{s}://} instead of \texttt{http://}
              \item default TCP port is 443 instead of 80
          \end{itemize}
    \item HTTP request may be sent after SSL Finished messages
    \item Protected information
          \begin{itemize}[nosep]
              \item URL, contents of the document, browser forms, cookies, headers
              \item page served over HTTPS may include elements retrieved using HTTP
          \end{itemize}
\end{itemize}
\section{DNSSEC}
\subsubsection*{Domain Name System (DNS)}
\begin{itemize}[nosep]
    \item Millions of domain names → distributed database
          \begin{itemize}[nosep]
              \item dynamic data $\leftarrow$ IP address for a host may change
              \item decentralized authority $\leftarrow$ each name has an owner
          \end{itemize}
    \item Hierarchical name space
          \begin{itemize}[nosep]
              \item domain: node in the DNS tree
              \item for each domain, there is an authoritative server
          \end{itemize}
    \item Authoritative server
          \begin{itemize}[nosep]
              \item responds to queries about the domains for which it is responsible
              \item may refer to other authoritative servers for a subdomain
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Queries and Responses}
\begin{itemize}[nosep]
    \item Transport protocol
          \begin{itemize}[nosep]
              \item UDP port 53
              \item TCP for long responses (and some tasks between nameservers)
          \end{itemize}
    \item Messages: query and reply
          \begin{itemize}[nosep]
              \item 16-bit identification field: match queries with replies
          \end{itemize}
    \item Caching
          \begin{itemize}[nosep]
              \item received responses are cached by servers
              \item each record has a Time-to-Live field, after expiry it must be queried again
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Weaknesses}
\begin{itemize}[nosep]
    \item DNS responses are not authenticated
          \begin{itemize}[nosep]
              \item responses can be sent over UDP transport protocol $\rightarrow$ anyone can respond from a spoofed (i.e., fake) IP address to a query
          \end{itemize}
    \item DNS is a key infrastructure
          \begin{itemize}[nosep]
              \item resolvers trust responses, users trust resolvers
              \item by tampering with responses, an attacker may direct users to malicious websites or direct e-mail to malicious servers
          \end{itemize}
    \item DNS cache poisoning
          \begin{itemize}[nosep]
              \item attacker sends malicious response to a DNS server, which caches it $\rightarrow$ malicious response is served to all clients using the server
              \item attacker does not have to be man-in-the-middle
          \end{itemize}
    \item Race to Respond First
          \begin{itemize}[nosep]
              \item If the attacker responds before the authoritative server, the DNS cache is poisoned with the malicious IP address
                    \begin{itemize}[nosep]
                        \item fake response is a single UDP packet from the spoofed (i.e., forged) IP address of the authoritative server
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Domain Name System Security Extensions (DNSSEC)}
\begin{itemize}[nosep]
    \item Set of extensions defined by the IETF to the DNS protocol
    \item Guarantees origin authenticity and data integrity of DNS replies
    \item Backwards compatible: responses can be interpreted by DNS servers and clients that do not support DNSSEC
          \begin{itemize}[nosep]
              \item of course, no guarantees are provided for these servers and clients
          \end{itemize}
    \item Does not provide confidentiality
          \begin{itemize}[nosep]
              \item responses are only authenticated but not encrypted
          \end{itemize}
    \item Based on public-key cryptography
          \begin{itemize}[nosep]
              \item every response is digitally signed
          \end{itemize}
\end{itemize}
\subsubsection*{DNSSEC Public Keys and Signatures}
\begin{itemize}[nosep]
    \item Signature algorithms: RSA-SHA1, RSA-SHA256, ECDSA-SHA256, \dots
    \item Trust anchor
          \begin{itemize}[nosep]
              \item known public key for an authoritative nameserver
              \item typically included in the operating systems
          \end{itemize}
    \item Authentication chain
          \begin{figure}[H]
              \begin{tikzpicture}
                  \node (anchor) {trust anchor};
                  \node[below right =of anchor] (root) {root};
                  \node[right =of root] (edu) {edu};
                  \node[right =of edu] (uh) {uh.edu};
                  \draw[->] (anchor) to[bend right] (root);
                  \draw[->] (root) -- (edu) node[above,pos=0.5] {signs};
                  \draw[->] (edu) -- (uh) node[above,pos=0.5] {signs};
              \end{tikzpicture}
          \end{figure}
    \item Responses may include
          \begin{itemize}[nosep]
              \item RRSIG: digital signature for the contents of the response
              \item DNSKEY: public key for a zone $\leftarrow$ if the response delegates
          \end{itemize}
\end{itemize}
\subsubsection*{DNS over HTTPS and TLS}
\begin{itemize}[nosep]
    \item DNS over HTTPS (DoH)
          \begin{itemize}[nosep]
              \item DNS queries and responses are encoded into HTTPS requests and responses
                    \begin{itemize}[nosep]
                        \item provides integrity and confidentiality
                        \item server may use HTTP/2 Push to send records in advance
                    \end{itemize}
              \item controversies and criticism: can impede traffic analysis for cybersecurity, may provide false sense of privacy, can impede traffic filtering by ISPs, \dots
          \end{itemize}
    \item DNS over TLS (DoT)
          \begin{itemize}[nosep]
              \item provides integrity and confidentiality
          \end{itemize}
\end{itemize}
\section{SSH}
\subsubsection*{Secure Shell (SSH) Protocol Stack}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,fill=gray!40,minimum width=6cm,minimum height=2.2cm,node distance=0cm}]
        \node (auth) {\textbf{SSH User}\\\textbf{Authentication Protocol}\\Authenticates the client-side\\user to the server.};
        \node[right =of auth] (conn) {\textbf{SSH}\\\textbf{Connection Protocol}\\Multiplexes the encrypted\\tunnel into several logical\\channels.};
        \path (auth.south west) rectangle ([yshift=-2.2cm]conn.south east) node[pos=0.5,minimum width=12.02cm] (transport) {\textbf{SSH Transport Layer Protocol}\\Provides server authentication, confidentiality, and integrity.\\It may optionally also provide compression.};
        \path (transport.south west) rectangle ([yshift=-2.2cm]transport.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (tcp) {\textbf{TCP}\\Transmission control protocol provides reliable, connection-\\oriented end-to-end delivery.};
        \path (tcp.south west) rectangle ([yshift=-2.2cm]tcp.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (ip) {\textbf{IP}\\Internet protocol provides datagram delivery across\\multiple networks.};
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSH Transport Layer}
\begin{itemize}
    \item Packet Exchange
    \item Identification string exchange
          \begin{itemize}[nosep]
              \item both the client and the server send: \texttt{SSH-protocolVersion-softwareVersion}
          \end{itemize}
    \item Algorithm negotiation (KEXINIT)
          \begin{itemize}[nosep]
              \item both the client and the server send the list of key exchange, encryption, MAC, and compression algorithms that they support
              \item chosen one: first on the client's list that is also on the server's list
          \end{itemize}
    \item End of key exchange (NEWKEYS)
          \begin{itemize}[nosep]
              \item start using the algorithms and keys
          \end{itemize}
\end{itemize}
\subsubsection*{Server authentication}
\begin{itemize}[nosep]
    \item servers signs a hash of all the earlier messages and the new symmetric key
    \item servers sends the signature and its public key to the client
    \item Client needs to verify the public-key sent by the server (i.e., verify that the public key belongs to the server host)
    \item Trust models
          \begin{itemize}[nosep]
              \item Certificate authority
                    \begin{itemize}[nosep]
                        \item client accepts public keys that are certified by a trusted CA
                    \end{itemize}
              \item Local database
                    \begin{itemize}[nosep]
                        \item client has a list of known pairs of hosts and public-keys
                        \item typically, each user has a list stored in its home directory
                              \begin{itemize}[nosep]
                                  \item default location: \texttt{\~{}/.ssh/known\_hosts}
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
    \item Known Hosts
          \begin{itemize}[nosep]
              \item First connection: verify and store host and public key
              \item Subsequence connections: compare to stored key
          \end{itemize}
\end{itemize}
\subsubsection*{SSH User Authentication Methods}
\begin{itemize}[nosep]
    \item Passwords
          \begin{itemize}[nosep]
              \item client sends a username and a password
          \end{itemize}
    \item Public key
          \begin{itemize}[nosep]
              \item client sends a public key and a signature based on the corresponding private key
              \item server checks if the public key is acceptable and verifies the signature
              \item typically, for every user account on the server host, there is a list of acceptable public keys stored at \texttt{\~{}/.ssh/authorized\_keys}
          \end{itemize}
    \item Host based
          \begin{itemize}[nosep]
              \item assumes that the server trusts the client host $\rightarrow$ since the client host has already authenticated the user, the server only needs to verify the identity of the client host
              \item client sends a signature based on the private key of the client host
          \end{itemize}
\end{itemize}
\section{E-mail security}
\subsubsection*{Weaknesses}
\begin{itemize}[nosep]
    \item Simple Mail Transfer Protocol
          \begin{itemize}[nosep]
              \item Outgoing emails can be tampered (integrity), eavesdropped (confidentiality), or forged (authenticity/integrity)
          \end{itemize}
\end{itemize}
\subsubsection*{E-Mail Threats}
\begin{itemize}[nosep]
    \item Spam: unsolicited messages sent in bulk
    \item E-mail scam: advance-fee scam (a.k.a. ``Nigerian Prince'' scam), job scam, \dots
    \item Phishing: collecting sensitive information (e.g., passwords, credit card numbers) or delivering malware by impersonating a trusted entity
    \item Spear-phishing: phishing directed at specific targets (e.g., users)
\end{itemize}
\subsubsection*{Pretty Good Privacy (PGP)}
\begin{itemize}[nosep]
    \item General-purpose application for secure communication between users
          \begin{itemize}[nosep]
              \item confidentiality and integrity protection for files and e-mail
              \item built on widely used asymmetric and symmetric-key cryptographic algorithms
              \item communicating users know each other's public keys $\rightarrow$ trust
          \end{itemize}
    \item IETF standard: OpenPGP
    \item Software
          \begin{itemize}[nosep]
              \item PGP went commercial in 1996
              \item GnuPG is a free and open-source implementation of OpenPGP
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Key Management}
\begin{itemize}[nosep]
    \item Each user may have multiple public-private key pairs $\rightarrow$ key identifiers are used to specify which key is used
    \item Key storage
          \begin{itemize}[nosep]
              \item private-key ring: user's own public-private key pairs
                    \begin{itemize}[nosep]
                        \item each entry has user identifier, key identifier, public key, encrypted private key
                        \item private key is encrypted using a passphrase
                    \end{itemize}
              \item public-key ring: public keys of other users
                    \begin{itemize}[nosep]
                        \item each entry has user identifier, key identifier, public key, trust levels, and signatures from other users
                        \item public-keys can be verified directly (e.g., delivery on secure channel) or using the “web of trust”
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Web of Trust}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={draw,circle,minimum size=1cm,label distance=0mm}]
        \node[fill=gray!40,label=above right:\textbf{You}] (you) {};
        \node[below left =of you,label=above:\textbf{A}] (a) {};
    \end{tikzpicture}
\end{figure}
\subsubsection*{PGP Authentication}
\begin{itemize}[nosep]
    \item Digital signature using the sender's private key
          \begin{itemize}[nosep]
              \item hash using MD5, SHA-1 or SHA-2, and then sign using RSA or DSA
          \end{itemize}
    \item Message may be compressed after signature
          \begin{itemize}[nosep]
              \item ZIP, Bzip2, \dots
          \end{itemize}
\end{itemize}
\subsubsection*{PGP Encryption}
\begin{itemize}
    \item Message may be compressed before encryption
          \begin{itemize}[nosep]
              \item ZIP, Bzip2, \dots
          \end{itemize}
    \item Generate a new 128-bit random symmetric key for each message
          \begin{itemize}[nosep]
              \item encrypt the message with the symmetric key using a block cipher in CFB mode (3DES, Blowfish, AES, \dots)
              \item encrypt the symmetric key with the recipient's public key using RSA or ElGamal
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME}
\begin{itemize}[nosep]
    \item MIME (Multipurpose Internet Mail Extension)
          \begin{itemize}[nosep]
              \item fixes the limitations posed by SMTP
              \item New headers fields
                    \begin{itemize}[nosep]
                        \item Content-Type: type of message content
                              \begin{itemize}[nosep]
                                  \item multipart type: body contains multiple parts, each having a header (e.g., images in HTML message, attachments)
                                  \item simple types (e.g., text/plain, image/jpeg, text/html)
                              \end{itemize}
                        \item Content-Transfer-Encoding: how binary data is represented in 7-bit ASCII (e.g., Base64, quoted-printable)
                    \end{itemize}
          \end{itemize}
    \item Secure / Multipurpose Internet Mail Extension (S/MIME)
          \begin{itemize}[nosep]
              \item security enhancement to the MIME e-mail format standard
              \item similar to PGP (Pretty Good Privacy)
                    \begin{itemize}[nosep]
                        \item both S/MIME and PGP enable encrypting and signing messages
                        \item both have IETF standards
                        \item both support state-of-the-art algorithms (AES, RSA, SHA-2, ...)
                        \item S/MIME is likely to emerge as the industry standard for commercial and organizational use (e.g., Microsoft Outlook and Gmail support S/MIME)
                        \item PGP is likely to remain the choice for personal e-mail security
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME Functionality}
\begin{itemize}[nosep]
    \item Functions
          \begin{itemize}[nosep]
              \item Signed data: message is digitally signed, and both the signature and the message are encoded (using Base64 representation)
              \item Clear-signed data: similar to signed data, but only the signature is encoded
              \item Enveloped data: encrypted message content and encrypted content-encryption key (i.e., session key) for one or more recipients (encoded using Base64)
              \item Signed and enveloped data: signing and encrypting may be nested
          \end{itemize}
    \item MIME content types
          \begin{itemize}[nosep]
              \item application/pkcs7-mime: signed or enveloped data
              \item multipart/signed: for clear-signed data, which contains a message and a signature (signature part is application/pkcs7-signature)
          \end{itemize}
\end{itemize}
\subsubsection*{S/MIME Public Keys}
\begin{itemize}[nosep]
    \item Public-key certificates
          \begin{itemize}[nosep]
              \item based on X.509 digital certificate format
              \item similar to PGP, digital certificates are distributed manually
              \item however, certificates may be signed by a CA
          \end{itemize}
    \item Public keys are used for
          \begin{itemize}[nosep]
              \item verifying signatures
              \item encrypting session keys
                    \begin{itemize}[nosep]
                        \item for enveloped data, the sender generates a random session key
                        \item session key is encrypted with each recipient’s public key, and the message contents are encrypted (using symmetric-key crypto) with the session key
                        \item upon receiving the message, a recipient can decrypt the session key, and then decrypt the message contents using the session key
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{DKIM}
\begin{itemize}
    \item E-Mail Spoofing Problem
    \item Attackers may use e-mail with forged sender addresses for spam/phishing
    \item Limitations of PGP and S/MIME
          \begin{itemize}[nosep]
              \item depend on the sending and receiving users, who must install or configure software, share public keys, etc.
              \item do not sign the message header, only the message contents
          \end{itemize}
    \item DomainKeys Identified Mail (DKIM)
          \begin{itemize}[nosep]
              \item specification for signing e-mail messages
              \item implemented on the servers, therefore transparent to the users
          \end{itemize}
\end{itemize}
\subsubsection*{DKIM Signature and Verification}
\begin{itemize}[nosep]
    \item Signature: Dkim-Signature header field
          \begin{itemize}[nosep]
              \item v: version
              \item a: algorithm used for signature (RSA-SHA1, RSA-SHA256)
              \item d: domain name
              \item s: selector (if there are multiple public keys)
              \item h: list of signed header fields
              \item bh: hash of the body part of the message
              \item b: signature in Base64
          \end{itemize}
    \item Verification
          \begin{itemize}[nosep]
              \item receiving SMTP server queries record s.\_domainkey.d using DNS
              \item nameserver returns the public key corresponding to the signing private key
          \end{itemize}
\end{itemize}
\subsubsection*{E-Mail Authentication Solutions}
\begin{itemize}[nosep]
    \item DomainKeys Identified Mail (DKIM)
    \item Sender Policy Framework (SPF)
          \begin{itemize}[nosep]
              \item another system for preventing e-mail spoofing
              \item DNS record lists all authorized sending hosts (i.e., e-mail servers) for a domain $\rightarrow$ receiving server can verify
              \item may be combined with DKIM
          \end{itemize}
    \item Domain-based Message Authentication, Reporting and Conformance (DMARC)
          \begin{itemize}[nosep]
              \item built on top of DKIM and SPF, published using DNS record
              \item enables domain owners to publish a policy (combination of DKIM and SPF) for verifying the legitimacy of e-mails from the domain
          \end{itemize}
\end{itemize}
\section{Authentication and access control}
\subsubsection*{Authentication}
\begin{itemize}[nosep]
    \item Authentication: reliably verifying the identity of someone or something
          \begin{itemize}[nosep]
              \item computer authenticates another computer
              \item computer authenticates a user
          \end{itemize}
    \item Types of authentication
          \begin{itemize}[nosep]
              \item one-way authentication or mutual authentication
              \item one-time or establishing a session (e.g., combined with key exchange)
          \end{itemize}
    \item Typical methods of computer authentication
          \begin{itemize}[nosep]
              \item cryptography-based
              \item address-based
          \end{itemize}
\end{itemize}
\subsubsection*{User Authentication}
\begin{itemize}[nosep]
    \item Types of user authentication factors
          \begin{itemize}[nosep]
              \item knowledge: some secret known only by the user (e.g., password)
              \item ownership: some physical object possessed by the user (e.g., bank card)
              \item inherence: some physical characteristic of the user (e.g., fingerprint)
          \end{itemize}
    \item Password-based user authentication
          \begin{itemize}[nosep]
              \item typical form of knowledge-based authentication
              \item verifier stores the password in a database or file
              \item often combined with cryptography-based approaches to protect the password from eavesdropping
              \item password must be easy to remember but hard to guess
          \end{itemize}
\end{itemize}
\subsubsection*{Password-Based Authentication}
\begin{itemize}
    \item Problem: easy-to-remember passwords are weak
          \begin{itemize}[nosep]
              \item Miller’s law: number of objects an average human can hold in working memory is $7 \pm 2$
              \item length of passwords that users can easily remember (i.e., not write down somewhere) is very limited
          \end{itemize}
    \item Brute-force attack: password guessing
          \begin{itemize}
              \item online: attacker must rely on the verifier to test the correctness of a password $\rightarrow$ verifier can limit the number of attempts (e.g., number of unsuccessful login)
              \item offline: attacker can test the correctness of a password on its own
          \end{itemize}
\end{itemize}
\subsubsection*{Password Storage}
\begin{itemize}[nosep]
    \item Cleartext passwords are insecure
          \begin{itemize}[nosep]
              \item system administrators (and other local users) may easily read passwords
              \item attackers who have compromised a system may be able to read passwords
          \end{itemize}
    \item Users tend to reuse passwords $\rightarrow$ breach may affect other systems as well
    \item Store the cryptographic hash of the password
          \begin{itemize}[nosep]
              \item during authentication, the user enters the plaintext password, and the verifier computes its hash and compares it with the stored hash
              \item attacker can perform offline guessing to recover the plaintext password
          \end{itemize}
    \item Brute-forcing multiple hashed passwords
          \begin{itemize}[nosep]
              \item first, precompute a table of [password, hash] values for possible passwords
              \item second, for each hashed password, look up the precomputed hash value
          \end{itemize}
\end{itemize}
\subsubsection*{Salting}
\begin{itemize}[nosep]
    \item Before hashing a password mix it with a salt value
          \begin{itemize}[nosep]
              \item both when the password is set and during verification
              \item verifier stores: username, salt, H(password + salt)
          \end{itemize}
    \item Salt value
          \begin{itemize}
              \item randomly generated for each user account
              \item may be stored in plaintext by the verifier
          \end{itemize}
    \item Salt values do not have to be memorized $\rightarrow$ strong randomness
          \begin{itemize}
              \item prevents precomputing hashes since the attacker cannot consider all possible salt values (different salt values require different precomputation)
              \item also hides identical passwords, which would result in identical hashes
          \end{itemize}
    \item However, it does not make guessing a single password harder (assuming that the attacker knows the salt)
\end{itemize}
\subsubsection*{Multi-Factor Authentication}
\begin{itemize}[nosep]
    \item User is authenticated only after passing multiple independent authentication mechanisms
          \begin{itemize}[nosep]
              \item typically, each mechanism is built on a different type of factor (e.g., knowledge + possession), so it is independent of the other mechanisms
              \item attacker must circumvent all authentication mechanisms to succeed
          \end{itemize}
    \item Possession factors
          \begin{itemize}[nosep]
              \item disconnected token: not connected to the client computer, typically the user manually enters authentication data displayed by the token
              \item connected token: physically connected to the client computer (e.g., USB token)
          \end{itemize}
    \item Inherence factors
          \begin{itemize}
              \item includes fingerprint, face, voice, or iris recognition
          \end{itemize}
\end{itemize}
\subsubsection*{Access Control}
\begin{itemize}[nosep]
    \item Access control (i.e., authorization): approving or rejecting access requests
    \item Abstractions
          \begin{itemize}[nosep]
              \item subjects: entities that can perform actions on the system
              \item objects: resources to which access must be controlled
          \end{itemize}
    \item Control access to objects based on a policy
\end{itemize}
\subsubsection*{Discretionary Access Control (DAC)}
\begin{itemize}[nosep]
    \item Allows access rights to be propagated at the subjects’ discretion
    \item Often implemented using the notion of owner
          \begin{itemize}[nosep]
              \item every object has an owner subject, who can set the permissions for that object
          \end{itemize}
    \item Used by popular operating systems (e.g., Unix and Windows)
    \item Problem: non-malicious users are not necessarily trustworthy
          \begin{itemize}[nosep]
              \item phishing: subjects may be tricked into propagating their access rights to malicious entities
              \item malware: malicious code running with a subject’s credentials can disclose or modify sensitive information
              \item large organizations working with sensitive data may need centralized control
          \end{itemize}
\end{itemize}
\subsubsection*{Mandatory Access Control (MAC)}
\begin{itemize}[nosep]
    \item Restricts the access of subjects to objects based on a system-wide set of rules
          \begin{itemize}[nosep]
              \item system-wide rules are set by a central authority (e.g., system administrator)
              \item policy is mandatory $\rightarrow$ users do not have full control over access to the resources that they create
          \end{itemize}
    \item Traditionally used for implementing multilevel security
          \begin{itemize}[nosep]
              \item objects have security classifications (e.g., “Top Secret”, “Secret”)
              \item subjects have security clearances
          \end{itemize}
    \item Available in some form on many modern operating systems
          \begin{itemize}[nosep]
              \item SELinux and AppArmor for Linux, and Mandatory Integrity Control for Windows
          \end{itemize}
    \item May be combined with DAC: grant access only if both DAC and MAC permit the access
\end{itemize}
\subsubsection*{Access Control Models}
\begin{itemize}[nosep]
    \item Access control list (ACL): list permissions for each object
          \begin{itemize}[nosep]
              \item for each object, list pairs of [subject, access right]
          \end{itemize}
    \item Role-based access control (RBAC): row oriented
          \begin{itemize}[nosep]
              \item create a set of roles (e.g., based on real-world job functions), and assign a role (or roles) to each subject
              \item for each role, list pairs of [object, access right]
          \end{itemize}
\end{itemize}
\subsubsection*{Unix Access Control}
\begin{itemize}[nosep]
    \item user: has a unique UID (special UID = 0 for root user)
    \item group (collection of multiple users): has a unique GID
    \item Access control abstraction
          \begin{itemize}[nosep]
              \item subject = process
                    \begin{itemize}[nosep]
                        \item has an effective UID and GID (as well as real and saved UIDs and GIDs)
                    \end{itemize}
              \item object = file
                    \begin{itemize}[nosep]
                        \item has an owner (UID) and a group (GID), typically inherited from the process that created the file
                        \item almost everything is a file on a Unix system (regular files, directories, devices, Unix domain sockets, \dots)
                    \end{itemize}
              \item Each file has 12 permission bits
                    \begin{itemize}[nosep]
                        \item read, write, and execute permission for owner, group, and others
                        \item set user ID (setuid), set group ID (setgid), sticky bits
                    \end{itemize}
              \item When a process wants to read/write/execute a file,
                    \begin{enumerate}[nosep]
                        \item if effective UID = file owner $\rightarrow$ use read/write/execute permission for owner
                        \item else if effective GID = file group $\rightarrow$ use read/write/execute permission for group
                        \item else $\rightarrow$ use read/write/execute permission for others
                    \end{enumerate}
              \item For directories,
                    \begin{itemize}[nosep]
                        \item read means listing the contents of the directory
                        \item write means creating, renaming, and deleting files in the directory
                        \item execute means accessing the files (and directories) within the directory (must also have execute permission on all the parent directories)
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Sticky, Set UID, and Set GID Bits}
\begin{itemize}[nosep]
    \item Sticky bit
          \begin{itemize}[nosep]
              \item when set on a directory, files within that directory can be renamed or deleted only by their owners, the directory owner, or a superuser
              \item for example, sticky bit is typically used on the /tmp directory
          \end{itemize}
    \item Set UID bit
          \begin{itemize}[nosep]
              \item when set on an executable file, the effective UID of a process executing the file is set to the file owner UID
              \item for example, set UID bit is typically used on the passwd command
          \end{itemize}
    \item Set GID bit
          \begin{itemize}[nosep]
              \item when set on an executable file, the effective GID of a process executing the file is set to the file group GID
              \item when set on a directory, new files created within will inherit the GID of the directory
          \end{itemize}
\end{itemize}
\section{Software vulnerabilities and countermeasures}
\section{Web vulnerabilities}
\section{Malware}
\section{Secure development}
\section{Detection}
\section{Isolation}
\section{Denial of Service attacks}
\section{Vulnerability scanners}
\end{document}
