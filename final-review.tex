\documentclass[final]{article}
\usepackage{final-review}
\begin{document}
\include{titlepage}
\section{Advanced crypto}
\subsection{Advanced Cryptographic Primitives}
\begin{itemize}[nosep]
    \item secure multiparty computation
    \item homomorphic encryption
\end{itemize}
\subsection{Commitment Schemes}
\subsubsection*{Commitment Problem}
\begin{itemize}[nosep]
    \item Bob “calls” the coin flip (i.e., heads or tails)
    \item Alice flips the coin
    \item Bob wins if her call is correct, Alice wins otherwise
\end{itemize}
Can we prevent Alice from cheating even if the players are not in the same physical location?

\subsubsection*{Commitment Scheme}
\begin{itemize}[nosep]
    \item Two phases
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ chooses a value $V$, $A$ sends a \textbf{commitment} of $V$ to $B$
              \item \underline{reveal}: $A$ reveals the value of $V$
          \end{enumerate}
    \item Example: coin flipping
          \begin{enumerate}[nosep]
              \item \underline{commit}: $A$ flips a coin, $A$ sends a commitment (i.e., coin is heads or tails) to $B$
          \end{enumerate}
          \begin{itemize}[nosep]
              \item $B$ calls the coin flip (i.e., heads or tails)
          \end{itemize}
          \begin{enumerate}[resume,nosep]
              \item \underline{reveal}: $A$ reveals the value of the coin flip
          \end{enumerate}
    \item Requirements for commitment scheme
          \begin{itemize}[nosep]
              \item $B$ cannot learn the value of $V$ from the commitment
              \item $A$ can reveal only the originally chosen value for a commitment
          \end{itemize}
\end{itemize}
\subsubsection*{Naive Attempt Using Hash Function}
\begin{itemize}[nosep]
    \item $H$: cryptographic hash function
    \item If the set of possible values of $V$ are small (e.g., ``heads'' or ``tails''), $B$ can learn $V$ by simply trying all possible values
\end{itemize}
\subsubsection*{Secure Commitment Using Hash Function}
\begin{itemize}[nosep]
    \item Collision-free hash function $\rightarrow$ $A$ cannot cheat by finding $V_1$ and $V_2$ such that $H(r_1 \mid r_2 \mid V_1) = H(r_1 \mid r_2 \mid V_2)$
          \begin{itemize}
              \item $r_1$ prevents pre-computation of colliding $V_1$ and $V_2$
          \end{itemize}
\end{itemize}
\subsection{Secret Sharing}
\begin{itemize}[nosep]
    \item \underline{Problem}: distribute a secret among $N$ participants such that
          \begin{itemize}[nosep]
              \item any group of at least $T$ participants can reconstruct the secret
              \item no group of fewer than $T$ participants can reconstruct any part of it
          \end{itemize}
    \item Types
          \begin{itemize}[nosep]
              \item \textbf{unconditionally secure}: information-theoretically secure (unbounded attacker)
              \item \textbf{conditionally secure}: typically more efficient
          \end{itemize}
\end{itemize}
\subsubsection*{Special Case: $T = N$}
\begin{itemize}[nosep]
    \item Unconditionally secure scheme:
          \begin{enumerate}[nosep]
              \item let the secret be a binary number $S$
              \item pick $N - 1$ random numbers $R_1$, $R_2$, \dots, $R_{N-1}$ of the same length
              \item give each participant $i$, $i < N$, the number $R_i$
              \item give the last participant the result of $S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}$
          \end{enumerate}
    \item $N$ participants can reconstruct the secret by XORing their numbers:
          \begin{itemize}[nosep]
              \item \begin{align*}&R_1 \xor R_2 \xor \dots \xor R_{N-1} \xor \left(S \xor R_1 \xor R_2 \xor \dots \xor R_{N-1}\right) \\&= (R_1 \xor R_1) \xor (R_2 \xor R_2) \xor \dots \xor (R_{N-1} \xor R_{N-1}) \xor S \\&= S\end{align*}
          \end{itemize}
    \item $N - 1$ participants can compute only $S \xor R_i$, where $i$ is the missing participant (or $R_1 \xor R_2 \xor \dots \xor R_{N-1}$ if the last participant is missing)
\end{itemize}
\subsection{Shamir’s Secret Sharing}
\begin{itemize}[nosep]
    \item Proposed by Shamir in 1979
    \item Unconditionally secure
    \item Special case $T=2$
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random number $A$
              \item let each participant’s share be a random point on the line $Ax + S$
          \end{enumerate}
          \begin{multicols}{2}
              \begin{figure}[H]
                  \begin{tikzpicture}
                      \begin{axis}[xlabel = $x$, ylabel=$y$, ticks=none, ymax=10]
                          \addplot[color=red,thick]{0.8 * x + 1};
                          \addlegendentry{$Ax + S$}
                          \draw[black] (0, 1) circle (2pt) node [right] {$(x_i, y_i)$};
                          \draw[black] (-3, -1.4) circle (2pt) node [right] {};
                          \draw[black] (3, 3.4) circle (2pt) node [right] {};
                      \end{axis}
                  \end{tikzpicture}
              \end{figure}
              \item $T = 2$ participants can reconstruct the secret since any two points define a line
              \item Single participant cannot learn the slope
          \end{multicols}
\end{itemize}
\subsubsection*{General Case}
\begin{itemize}[nosep]
    \item Arbitrary T:
          \begin{enumerate}[nosep]
              \item let the secret be a number $S$
              \item pick random numbers $A_1$, $A_2$, $\dots$, $A_{T-1}$
              \item let each participant's share be a random point from the curve
                    \[y = S + A_1 x + A_2 x^2 + \dots + A_{T-1}x^{T-1}\]
          \end{enumerate}
    \item At least $T$ points are necessary to define a polynomial of degree $T - 1$
    \item Example $T = 3$
          \begin{itemize}[nosep]
              \item secret is a parabola (i.e., $A_2 x^2 + A1 x + S$)
              \item there an infinite number of parabolas fitting two points
              \item but three point define one uniquely
          \end{itemize}
\end{itemize}
\subsection{Secure Multiparty Computation}
\begin{itemize}[nosep]
    \item \underline{Problem}: $N$ participants with private data $d_1$, $d_2$, \dots, $d_N$
          \begin{itemize}[nosep]
              \item participants would like to compute the value $F(d_1, d_2, \dots, d_N)$ of a public function $F$ over their private data
              \item no participant $i$ would like to reveal any information about its data $d_i$
          \end{itemize}
    \item Requirements
          \begin{itemize}
              \item \textbf{privacy}: no information is revealed about any private data (other than what is revealed by the public output)
              \item \textbf{correctness}: public function is correctly computed
          \end{itemize}
    \item Adversaries may be semi-honest (passive) or malicious (active)
\end{itemize}
\section{WiFi security}
\subsection{Security Challenge}
\begin{itemize}[nosep]
    \item \underline{Problem}: no inherent physical protection
    \item \textbf{joining} a network does not require physical access
    \item radio transmissions are broadcast $\rightarrow$ anyone in range can \textbf{eavesdrop}
    \item \textbf{injecting} new messages or \textbf{replaying} old messages is possible
    \item \textbf{jamming} attacks against availability
    \item jamming and injecting messages can be combined into \textbf{tampering} attacks
\end{itemize}
\subsection{Simple “Solutions” for Access Control}
\subsubsection*{Hidden SSID}
\begin{itemize}[nosep]
    \item Association request must contain the SSID of the network
          \begin{itemize}[nosep]
              \item by default, the AP broadcasts it periodically in the beacon
          \end{itemize}
    \item AP may be configured to \textbf{stop announcing the SSID} $\rightarrow$ SSID may be be used as a ``password''
    \item However,
          \begin{itemize}[nosep]
              \item SSID must be hard to guess
              \item every authorized user must know the SSID
              \item \textbf{SSID can be easily eavesdropped} whenever an authorized station connects to the network $\rightarrow$ does not provide any security
          \end{itemize}
    \item Tools are available for eavesdropping (e.g. Aircrack-ng)
\end{itemize}
\subsubsection*{MAC Address Based Filtering}
\begin{itemize}[nosep]
    \item AP may be configured to \textbf{allow only devices with certain MAC addresses} to connect
          \begin{itemize}[nosep]
              \item MAC addresses of all authorized devices must be registered in advance
          \end{itemize}
    \item However,
          \begin{itemize}[nosep]
              \item \textbf{MAC address is sent in plaintext} in every packet
              \item many WLAN devices allow their MAC addresses to be changed $\rightarrow$ attacker can easily impersonate an authorized user
          \end{itemize}
\end{itemize}
\subsection{802.11 Security Standards}
\subsubsection*{WEP}
\begin{itemize}
    \item security is based on a 40 or 104-bit secret key
          \begin{itemize}[nosep]
              \item WiFi “password” shared by all users
          \end{itemize}
    \item \underline{confidentiality}: RC4 stream cipher
          \begin{itemize}[nosep]
              \item key is extended by a 24-bit IV, which is changed for each message $\rightarrow$ used as nonce to prevent key reuse problems
          \end{itemize}
    \item \underline{integrity}: encrypted CRC32 (Cyclic Redundancy Check) checksum
    \item \underline{access control}: challenge-response between AP and station
\end{itemize}
\subsubsection*{WEP Design Flaws}
\begin{itemize}[nosep]
    \item Authentication
          \begin{itemize}[nosep]
              \item \textbf{one-way authentication} (only for station) $\rightarrow$ AP can be impersonated
          \end{itemize}
    \item Integrity protection
          \begin{itemize}[nosep]
              \item based on \textbf{error-detection code} (CRC32) instead of cryptographic hash $\rightarrow$ forging authentication tags is trivial
              \item \textbf{no message replay protection}
          \end{itemize}
    \item Key usage
          \begin{itemize}
              \item \textbf{no session key}: long-term key used for all purposes (authentication, encryption, integrity protection)
              \item \textbf{short nonce} (i.e., 24-bit IV) $\rightarrow$ danger of key reuse for stream cipher
                    \begin{itemize}[nosep]
                        \item busy network with 1000 packets per second reuses in less than 5 hours
                    \end{itemize}
              \item vulnerable to Fluhrer-Mantin-Shamir Attack
                    \begin{itemize}[nosep]
                        \item In practice, WEP keys can be broken in a matter of minutes (or less) $\rightarrow$ WEP is \textbf{not secure}
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsection{WiFi Protected Access (WPA)}
\subsubsection*{WPA}
\begin{itemize}[nosep]
    \item Standard: 802.11i TKIP (Temporal Key Integrity Protocol
    \item Design goals: \textbf{fix the flaws of WEP} and be \textbf{compatible with legacy hardware}
    \item Overview
          \begin{itemize}
              \item \underline{key usage}: session key is established during a secure two-way authentication
              \item \underline{confidentiality}: RC4 encryption, but with \textbf{48-bit IV}, which is \textbf{mixed thoroughly} with the session key and source MAC address
                    \begin{itemize}[nosep]
                        \item prevents key reuse and the Fluhrer-Mantin-Shamir attack
                    \end{itemize}
              \item \underline{integrity}: 64-bit message integrity codes computed using Michael, which is \textbf{computationally very efficient} but provides only ~20 bits of effective security
                    \begin{itemize}[nosep]
                        \item after wrong code, station is banned for a minute and needs to re-authenticate
                    \end{itemize}
              \item Deprecated in later revisions of the standard
          \end{itemize}
\end{itemize}
\begin{itemize}
    \item
\end{itemize}
\subsubsection*{WPA-2}
\begin{itemize}[nosep]
    \item Standard: \textbf{IEEE 802.11i}
    \item WPA 2 Devices can be certified by the Wi-Fi Alliance
\end{itemize}
\subsubsection*{Phases}
\begin{enumerate}[nosep]
    \item Discovery
          \begin{itemize}
              \item agree on what authentication method and ciphers to use
          \end{itemize}
    \item Authentication
          \begin{itemize}[nosep]
              \item may use an authentication server
              \item create a master session key
          \end{itemize}
    \item Key management
          \begin{itemize}[nosep]
              \item derive keys for various purposes
          \end{itemize}
    \item Protected data transfer
    \item Connection termination
\end{enumerate}
\subsubsection*{Discovery Phase}
\begin{itemize}[nosep]
    \item \underline{Goal}: station and AP may support different sets of authentication methods and ciphers $\rightarrow$ they need to agree on which ones they will use
    \item \textbf{Authentication and key-management suite}: how to perform mutual authentication and derive fresh keys
          \begin{itemize}[nosep]
              \item IEEE 802.1X, pre-shared key (PSK), or vendor-specific
          \end{itemize}
    \item \textbf{Cipher suite}: what ciphers to use for confidentiality and integrity
          \begin{itemize}
              \item WEP, TKIP, CCMP, or vendor-specific
          \end{itemize}
    \item Protocol
          \begin{enumerate}[nosep]
              \item AP can periodically \textbf{broadcast} its security capabilities using a \textbf{Beacon} (or station can ask for it using a Probe Request message)
              \item Station \textbf{specifies} an authentication and cipher suite in an \textbf{Association Request}
              \item if the AP \textbf{accepts} the specified suites, it sends an \textbf{Association Response}
          \end{enumerate}
\end{itemize}
\subsubsection*{Authentication Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item mutual authentication:
                    \begin{enumerate}[nosep, label=\arabic*)]
                        \item only authorized stations can use the network
                        \item station is assured that it communicates with a legitimate network
                    \end{enumerate}
              \item generate \textbf{pairwise master key} (PMK)
          \end{itemize}
    \item Approaches
          \begin{itemize}[nosep]
              \item Pre-shared key (PSK)
                    \begin{itemize}[nosep]
                        \item password is deployed on each station and the AP manually
                        \item PMK = PSK = generated from the password using a hash function
                        \item ideal for home and small office networks
                    \end{itemize}
              \item IEEE 802.1X
          \end{itemize}
\end{itemize}
\subsubsection*{Key-Management Phase}
\begin{itemize}[nosep]
    \item \underline{Goals:}
          \begin{itemize}[nosep]
              \item derive \textbf{pairwise transient keys} from the PMK
              \item distribute \textbf{group keys}
          \end{itemize}
    \item Pairwise transient key (PTK)
          \begin{itemize}[nosep]
              \item protecting data between station and AP
              \item generated from PMK and the AP's and station's MAC addresses and nonces
          \end{itemize}
    \item Group temporal key (GTK)
          \begin{itemize}[nosep]
              \item protecting multicast communication
              \item group master key (GMK): generated randomly by the AP
              \item distributed using the PTK
          \end{itemize}
\end{itemize}
\subsubsection*{Protected Data Transfer Phase}
\begin{itemize}[nosep]
    \item Standard defines two schemes: TKIP and CCMP
    \item TKIP: see WPA
    \item CCMP (Counter mode CBC-MAC Protocol)
          \begin{itemize}[nosep]
              \item based on the CCM (Counter with CBC-MAC) authenticated encryption mode
              \item integrity: CBC-MAC based on AES encryption
              \item confidentiality: AES encryption in counter (CTR) mode
              \item same 128-bit key for integrity and confidentiality (from PTK)
              \item 48-bit packet number to prevent replay attacks
          \end{itemize}
\end{itemize}
\subsubsection*{IEEE 802.1X}
\begin{itemize}[nosep]
    \item Standard for port-based network access control
    \item Entities
          \begin{itemize}[nosep]
              \item supplicant = station
              \item authenticator = access point
              \item authentication server
          \end{itemize}
    \item Port-based: supplicant can access only the authentication server until the authentication succeeds
    \item Authentication server does not have to be implemented on the access point $\rightarrow$ little overhead for the access point
\end{itemize}
\subsubsection*{EAP Authentication Methods}
\begin{itemize}[nosep]
    \item Extensible framework, not a specific authentication mechanism
    \item Example methods
          \begin{itemize}[nosep]
              \item EAP-TLS: based on public-key certificates
              \item EAP-GPSK (Generalized Pre-Shared Key): based on secret keys shared by the client and the server, uses symmetric-key cryptography
          \end{itemize}
\end{itemize}
\section{IPSec}
\begin{itemize}[nosep]
    \item Collection of protocols and mechanisms, standardized by the Internet Engineering Task Force (IETF) in a series of publications
    \item Provides
          \begin{itemize}[nosep]
              \item data confidentiality and integrity
              \item source authentication (prevent address spoofing, i.e., sending from fake address)
              \item protection against packet replay
          \end{itemize}
    \item Below the transport layer (TCP or UDP) $\rightarrow$ transparent to applications
    \item End-to-end security between two hosts, a host and a network, or between two networks
    \item Example Applications of IPSec
          \begin{itemize}[nosep]
              \item Secure remote access over the Internet
              \item Secure virtual private network
          \end{itemize}
\end{itemize}
\subsection{Transport Mode and Tunnel Mode}
\begin{itemize}[nosep]
    \item Transport mode
          \begin{itemize}[nosep]
              \item protects the payload of the IP packet
              \item typically host-to-host communication
          \end{itemize}
    \item Tunnel mode
          \begin{itemize}[nosep]
              \item protects the entire IP packet by encapsulating it in the payload of a new IP packet
              \item typically host-to-network or network-to-network communication
          \end{itemize}
\end{itemize}
\begin{table}[H]
    \begin{tabular}{lll}
        \multicolumn{3}{c}{Protocol}                                                                             \\
                 & Authentication Headher (AH)                   & Encapsulating Security Payloads (ESP)         \\\toprule
        Modes    & \multicolumn{2}{c}{both transport and tunnel}                                                 \\
        Provides & integrity, replay protection                  & integrity, confidentiality, replay protection \\
        Protects & payload and IP header                         & payload                                       \\\bottomrule
    \end{tabular}
\end{table}
\subsubsection*{Authentication Header}
\begin{itemize}[nosep]
    \item Services
          \begin{itemize}[nosep]
              \item data and origin integrity
              \item replay-prevention
          \end{itemize}
    \item Message authentication
          \begin{itemize}[nosep]
              \item computed from immutable fields of the IP header, AH header (except ICV), and original payload
              \item algorithms: HMAC-MD5, HMAC-SHA-1, HMAC-SHA-2, \dots
          \end{itemize}
\end{itemize}
\subsubsection*{Encapsulating Security Payload}
\begin{itemize}[nosep]
    \item Services: confidentiality, integrity (optional), replay prevention
    \item Encryption: AES-CBC, 3DES-CBC, \dots
    \item Message authentication: HMAC-SHA-1, AES-GMAC, \dots
    \item Authenticated encryption: AES-GCM
\end{itemize}
\subsubsection*{Combining Modes and Protocols}
\begin{itemize}[nosep]
    \item Tunnel mode advantage: requires support only at the gateways
    \item Transport mode advantage: requires support only at the hosts
    \item AH advantage: authenticates some elements of the original header
    \item ESP advantage: protects both integrity and confidentiality
    \item Combining modes
          \begin{itemize}[nosep]
              \item IPSec tunnel can carry any IP packet $\rightarrow$ IPSec transport or tunnel packets can be sent through an IPSec tunnel
              \item IPSec transport can protect any IP packet $\rightarrow$ IPSec transport or tunnel packets can be protected by outer IPSec transport
              \item \dots
              \item can be nested to any depth
          \end{itemize}
    \item Combination Examples
          \begin{enumerate}[nosep]
              \item AH in transport (for integrity) + ESP in transport (for confidentiality)
              \item IPSec packets over tunnel
          \end{enumerate}
\end{itemize}
\section{SSL / TLS}
\subsubsection*{Secure Socket Layer}
\begin{itemize}[nosep]
    \item End-to-end security between two applications
    \item Endpoint applications can implement it without the help of the operating systems or any intermediate devices
    \item Developed by Netscape for securing HTTP $\rightarrow$ HTTPS = HTTP over SSL
    \item very widely used, not just for HTTP (e.g., FTP, POP3, IMAP)
\end{itemize}
\subsubsection*{Overview}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,rectangle,fill=gray!40,node distance=0cm,minimum height=1.5cm, minimum width=2cm}]
        \node (handshake) {SSL\\Handshake\\Protocol};
        \node[right=of handshake] (cipher) {SSL Change\\Cipher Spec\\Protocol};
        \node[right=of cipher] (alert) {SSL Alert\\Protocol};
        \node[right=of alert] (http) {HTTP};
        \path (handshake.south west) rectangle ([yshift=-1.5cm]http.south east) node[pos=0.5,minimum width=8.15cm] (record) {SSL Record Protocol};
        \path (record.south west) rectangle ([yshift=-1.5cm]record.south east) node[pos=0.5,minimum width=8.15cm] (tcp) {TCP};
        \path (tcp.south west) rectangle ([yshift=-1.5cm]tcp.south east) node[pos=0.5,minimum width=8.15cm] (ip) {IP};

        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=handshake, node distance=4cm] (negotiation) {algorithm negotiation,\\key exchange,\\authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,left of=record, node distance=7cm] (encryption) {encryption and\\message authentication};
        \node[minimum size=0cm,inner sep=-0.1cm,fill=none,draw=none,above of=cipher, node distance=2cm] (switch) {switching algorithms\\and keys};
        \node[minimum size=0cm,inner sep=-0.05cm,fill=none,draw=none,above of=http,node distance=2cm] (sending) {sending SSL related\\alerts, which may\\terminate the connection};

        \draw[->] (negotiation.north east) to[bend left] ([xshift=0.5cm,yshift=0.1cm]handshake.north west);
        \draw[->] (encryption.north east) to[bend left] (record.west);
        \draw[->] (switch.south) to ([yshift=0.1cm]cipher.north);
        \draw[->] (sending.south west) to[bend right] ([xshift=0.5cm,yshift=0.1cm]alert.north west);
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSL Record Protocol}
\begin{itemize}[nosep]
    \item Security 528
          \begin{itemize}[nosep]
              \item confidentiality: symmetric-key encryption (AES GCM, Salsa20, \dots)
              \item integrity: message authentication codes based on symmetric-key cryptography (HMAC-SHA256, \dots)
          \end{itemize}
    \item Additional Services
          \begin{itemize}[nosep]
              \item fragmentation: fragment application data into records of at most 16 KiB
              \item lossless compression: optional (default is no compression)
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Handshake Protocol}
\begin{itemize}[nosep]
    \item Phase 1: establish security capabilities
          \begin{itemize}[nosep]
              \item client\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by the client
                        \item nonce (timestamp + random value)
                        \item cipher suite: list of key-exchange methods, as well as encryption and MAC algorithms
                        \item compression method: list of supported compression algorithms
                    \end{itemize}
              \item server\_hello:
                    \begin{itemize}[nosep]
                        \item highest SSL version supported by both the
                              client and the server
                        \item nonce
                        \item chosen cipher suite and compression method
                    \end{itemize}
          \end{itemize}
    \item Phase 2: server authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate (may be a chain)
              \item server\_key\_exchange (optional):
                    \begin{itemize}[nosep]
                        \item parameters for Anonymous or Ephemeral Diffie-Hellman exchange
                        \item public-key for RSA exchange if the certificate contains only a signing key
                        \item signed by the server (together with the nonces)
                    \end{itemize}
              \item certificate\_request (optional): ask client for an X.509 certificate
              \item server\_hello\_done: server is finished
          \end{itemize}
    \item Phase 3: client authentication and key exchange
          \begin{itemize}[nosep]
              \item certificate (optional): X.509 certificate if the server asked for a client certificate
              \item client\_key\_exchange:
                    \begin{itemize}[nosep]
                        \item pre-master secret encrypted using public RSA key of the server
                        \item parameters for D-H exchange
                    \end{itemize}
              \item certificate\_verify (optional): digital signature of all previous handshake messages
          \end{itemize}
\end{itemize}
\subsubsection*{Key Exchange Methods}
\begin{itemize}[nosep]
    \item Goal: exchange or agree on a pre-master secret (PMS)
    \item RSA
          \begin{itemize}[nosep]
              \item client generates pre-master secret (PMS)
              \item sends PMS to the server encrypted using RSA public-key encryption
          \end{itemize}
    \item Diffie-Hellman protocol
          \begin{itemize}[nosep]
              \item anonymous D-H: basic D-H with no authentication
              \item fixed D-H: D-H parameters of the server ($X_A$ and $Y_A$) are fixed and $Y_A$ is contained in a digital certificate
              \item ephemeral D-H: D-H with authentication
          \end{itemize}
\end{itemize}
\subsubsection*{SSL Change Cipher Spec Protocol}
\begin{itemize}[nosep]
    \item Same for client and server
          \begin{itemize}[nosep]
              \item change\_cipher\_spec: signals that the communication party is switching to the negotiated cryptographic algorithms and keys
              \item finished: hash value computed from the master secret and all handshake messages using HMAC with SHA hash function
          \end{itemize}
\end{itemize}
\subsubsection*{Session Resume}
\begin{itemize}
    \item Authentication and key exchange are complex $\rightarrow$ result needs to be reusable
    \item Session
          \begin{itemize}[nosep]
              \item association between a client and a server
              \item cipher suite, compression method, and master secret
          \end{itemize}
    \item Connection
          \begin{itemize}[nosep]
              \item within a session
              \item keys and IVs for encryption and message authentication
          \end{itemize}
    \item Session ID: identifies a session
          \begin{itemize}[nosep]
              \item sent in ClientHello $\rightarrow$ may specify an existing session to be resumed
              \item sent in ServerHello $\rightarrow$ server can accept resume by sending the same ID
          \end{itemize}
    \item Session resume skips all messages in the Handshake after the ClientHello and ServerHello messages
          \begin{itemize}[nosep]
              \item new keys and IVs are generated from the nonces in the Hello messages
          \end{itemize}
\end{itemize}

\subsubsection*{Transport Layer Security}
\begin{itemize}[nosep]
    \item only minor differences compared to SSL 3.0:
          \begin{itemize}[nosep]
              \item pseudorandom function for generating keys and MAC is based on HMAC
              \item variable length padding (may prevent traffic analysis)
              \item other minor changes
          \end{itemize}
\end{itemize}
\subsubsection*{HTTPS}
\begin{itemize}[nosep]
    \item HTTP over SSL/TLS
    \item Between the web browser and server:
          \begin{itemize}[nosep]
              \item HTTP client = SSL client
              \item HTTP server = SSL server
          \end{itemize}
    \item Conventions
          \begin{itemize}[nosep]
              \item URL: \texttt{http\textbf{s}://} instead of \texttt{http://}
              \item default TCP port is 443 instead of 80
          \end{itemize}
    \item HTTP request may be sent after SSL Finished messages
    \item Protected information
          \begin{itemize}[nosep]
              \item URL, contents of the document, browser forms, cookies, headers
              \item page served over HTTPS may include elements retrieved using HTTP
          \end{itemize}
\end{itemize}
\section{DNSSEC}
\subsubsection*{Domain Name System (DNS)}
\begin{itemize}[nosep]
    \item Millions of domain names → distributed database
          \begin{itemize}[nosep]
              \item dynamic data $\leftarrow$ IP address for a host may change
              \item decentralized authority $\leftarrow$ each name has an owner
          \end{itemize}
    \item Hierarchical name space
          \begin{itemize}[nosep]
              \item domain: node in the DNS tree
              \item for each domain, there is an authoritative server
          \end{itemize}
    \item Authoritative server
          \begin{itemize}[nosep]
              \item responds to queries about the domains for which it is responsible
              \item may refer to other authoritative servers for a subdomain
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Queries and Responses}
\begin{itemize}[nosep]
    \item Transport protocol
          \begin{itemize}[nosep]
              \item UDP port 53
              \item TCP for long responses (and some tasks between nameservers)
          \end{itemize}
    \item Messages: query and reply
          \begin{itemize}[nosep]
              \item 16-bit identification field: match queries with replies
          \end{itemize}
    \item Caching
          \begin{itemize}[nosep]
              \item received responses are cached by servers
              \item each record has a Time-to-Live field, after expiry it must be queried again
          \end{itemize}
\end{itemize}
\subsubsection*{DNS Weaknesses}
\begin{itemize}[nosep]
    \item DNS responses are not authenticated
          \begin{itemize}[nosep]
              \item responses can be sent over UDP transport protocol $\rightarrow$ anyone can respond from a spoofed (i.e., fake) IP address to a query
          \end{itemize}
    \item DNS is a key infrastructure
          \begin{itemize}[nosep]
              \item resolvers trust responses, users trust resolvers
              \item by tampering with responses, an attacker may direct users to malicious websites or direct e-mail to malicious servers
          \end{itemize}
    \item DNS cache poisoning
          \begin{itemize}[nosep]
              \item attacker sends malicious response to a DNS server, which caches it $\rightarrow$ malicious response is served to all clients using the server
              \item attacker does not have to be man-in-the-middle
          \end{itemize}
    \item Race to Respond First
          \begin{itemize}[nosep]
              \item If the attacker responds before the authoritative server, the DNS cache is poisoned with the malicious IP address
                    \begin{itemize}[nosep]
                        \item fake response is a single UDP packet from the spoofed (i.e., forged) IP address of the authoritative server
                    \end{itemize}
          \end{itemize}
\end{itemize}
\subsubsection*{Domain Name System Security Extensions (DNSSEC)}
\begin{itemize}[nosep]
    \item Set of extensions defined by the IETF to the DNS protocol
    \item Guarantees origin authenticity and data integrity of DNS replies
    \item Backwards compatible: responses can be interpreted by DNS servers and clients that do not support DNSSEC
          \begin{itemize}[nosep]
              \item of course, no guarantees are provided for these servers and clients
          \end{itemize}
    \item Does not provide confidentiality
          \begin{itemize}[nosep]
              \item responses are only authenticated but not encrypted
          \end{itemize}
    \item Based on public-key cryptography
          \begin{itemize}[nosep]
              \item every response is digitally signed
          \end{itemize}
\end{itemize}
\subsubsection*{DNSSEC Public Keys and Signatures}
\begin{itemize}[nosep]
    \item Signature algorithms: RSA-SHA1, RSA-SHA256, ECDSA-SHA256, \dots
    \item Trust anchor
          \begin{itemize}[nosep]
              \item known public key for an authoritative nameserver
              \item typically included in the operating systems
          \end{itemize}
    \item Authentication chain
          \begin{figure}[H]
              \begin{tikzpicture}
                  \node (anchor) {trust anchor};
                  \node[below right =of anchor] (root) {root};
                  \node[right =of root] (edu) {edu};
                  \node[right =of edu] (uh) {uh.edu};
                  \draw[->] (anchor) to[bend right] (root);
                  \draw[->] (root) -- (edu) node[above,pos=0.5] {signs};
                  \draw[->] (edu) -- (uh) node[above,pos=0.5] {signs};
              \end{tikzpicture}
          \end{figure}
    \item Responses may include
          \begin{itemize}[nosep]
              \item RRSIG: digital signature for the contents of the response
              \item DNSKEY: public key for a zone $\leftarrow$ if the response delegates
          \end{itemize}
\end{itemize}
\subsubsection*{DNS over HTTPS and TLS}
\begin{itemize}[nosep]
    \item DNS over HTTPS (DoH)
          \begin{itemize}[nosep]
              \item DNS queries and responses are encoded into HTTPS requests and responses
                    \begin{itemize}[nosep]
                        \item provides integrity and confidentiality
                        \item server may use HTTP/2 Push to send records in advance
                    \end{itemize}
              \item controversies and criticism: can impede traffic analysis for cybersecurity, may provide false sense of privacy, can impede traffic filtering by ISPs, \dots
          \end{itemize}
    \item DNS over TLS (DoT)
          \begin{itemize}[nosep]
              \item provides integrity and confidentiality
          \end{itemize}
\end{itemize}
\section{SSH}
\subsubsection*{Secure Shell (SSH) Protocol Stack}
\begin{figure}[H]
    \begin{tikzpicture}[every node/.style={align=center,draw,fill=gray!40,minimum width=6cm,minimum height=2.2cm,node distance=0cm}]
        \node (auth) {\textbf{SSH User}\\\textbf{Authentication Protocol}\\Authenticates the client-side\\user to the server.};
        \node[right =of auth] (conn) {\textbf{SSH}\\\textbf{Connection Protocol}\\Multiplexes the encrypted\\tunnel into several logical\\channels.};
        \path (auth.south west) rectangle ([yshift=-2.2cm]conn.south east) node[pos=0.5,minimum width=12.02cm] (transport) {\textbf{SSH Transport Layer Protocol}\\Provides server authentication, confidentiality, and integrity.\\It may optionally also provide compression.};
        \path (transport.south west) rectangle ([yshift=-2.2cm]transport.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (tcp) {\textbf{TCP}\\Transmission control protocol provides reliable, connection-\\oriented end-to-end delivery.};
        \path (tcp.south west) rectangle ([yshift=-2.2cm]tcp.south east) node[fill=none,pos=0.5,minimum width=12.02cm] (ip) {\textbf{IP}\\Internet protocol provides datagram delivery across\\multiple networks.};
    \end{tikzpicture}
\end{figure}
\subsubsection*{SSH Transport Layer}
\begin{itemize}
    \item Packet Exchange
    \item Identification string exchange
          \begin{itemize}[nosep]
              \item both the client and the server send: \texttt{SSH-protocolVersion-softwareVersion}
          \end{itemize}
    \item Algorithm negotiation (KEXINIT)
          \begin{itemize}[nosep]
              \item both the client and the server send the list of key exchange, encryption, MAC, and compression algorithms that they support
              \item chosen one: first on the client’s list that is also on the server’s list
          \end{itemize}
    \item End of key exchange (NEWKEYS)
          \begin{itemize}[nosep]
              \item start using the algorithms and keys
          \end{itemize}
\end{itemize}
\subsubsection*{Server authentication}
\begin{itemize}[nosep]
    \item servers signs a hash of all the earlier messages and the new symmetric key
    \item servers sends the signature and its public key to the client
    \item Client needs to verify the public-key sent by the server (i.e., verify that the public key belongs to the server host)
    \item Trust models
          \begin{itemize}[nosep]
              \item Certificate authority
                    \begin{itemize}[nosep]
                        \item client accepts public keys that are certified by a trusted CA
                    \end{itemize}
              \item Local database
                    \begin{itemize}[nosep]
                        \item client has a list of known pairs of hosts and public-keys
                        \item typically, each user has a list stored in its home directory
                              \begin{itemize}[nosep]
                                  \item default location: \texttt{\~{}/.ssh/known\_hosts}
                              \end{itemize}
                    \end{itemize}
          \end{itemize}
    \item Known Hosts
          \begin{itemize}[nosep]
              \item First connection: verify and store host and public key
              \item Subsequence connections: compare to stored key
          \end{itemize}
\end{itemize}
\subsubsection*{SSH User Authentication Methods}
\begin{itemize}[nosep]
    \item Passwords
          \begin{itemize}[nosep]
              \item client sends a username and a password
          \end{itemize}
    \item Public key
          \begin{itemize}[nosep]
              \item client sends a public key and a signature based on the corresponding private key
              \item server checks if the public key is acceptable and verifies the signature
              \item typically, for every user account on the server host, there is a list of acceptable public keys stored at \texttt{\~{}/.ssh/authorized\_keys}
          \end{itemize}
    \item Host based
          \begin{itemize}[nosep]
              \item assumes that the server trusts the client host $\rightarrow$ since the client host has already authenticated the user, the server only needs to verify the identity of the client host
              \item client sends a signature based on the private key of the client host
          \end{itemize}
\end{itemize}
\section{E-mail security}
\section{Authentication and access control}
\section{Software vulnerabilities and countermeasures}
\section{Web vulnerabilities}
\section{Malware}
\section{Secure development}
\section{Detection}
\section{Isolation}
\section{Denial of Service attacks}
\section{Vulnerability scanners}
\end{document}
